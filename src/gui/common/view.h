/**
 * @file view.h
 * @brief Публичный API для универсального модуля отображения BrickGame
 *
 * Этот заголовочный файл определяет абстрактный интерфейс (View) для реализации любых видов отображения
 * (CLI, GUI, Web и др.) в проекте BrickGame. View полностью изолирован от игровой логики (модели).
 * Контроллер связывает модель и представление через этот API.
 *
 * Основные идеи:
 * - ViewHandle_t — абстрактный указатель на внутренний контекст интерфейса.
 * - Все функции работают только с этим handle, обеспечивая модульность.
 * - Универсальные структуры для текста, чисел, матриц.
 * - Ввод описывается через InputEvent_t.
 * - Поддержка версионирования и обработки ошибок.
 *
 * @author provemet
 * @date December 2024
 * @defgroup common_view Публичный интерфейс библиотек отображения игр BrickGame
 * @ingroup View
 * @version
 * @{
 */

#ifndef VIEW_H
#define VIEW_H

#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @typedef ViewHandle_t
 * @brief Абстрактный указатель на внутренний контекст View-модуля.
 *
 * Контроллер получает этот handle при инициализации и передаёт во все функции View.
 * Содержимое скрыто — обеспечивает модульность и изоляцию реализации.
 *
 * @note Поведение не определено, если handle используется после вызова shutdown().
 * @note Значение NULL может интерпретироваться как "неинициализированный контекст".
 *       Реализация должна корректно обрабатывать передачу NULL в функции.
 */
typedef void *ViewHandle_t;

/**
 * @enum ViewResult_t
 * @brief Коды возврата функций интерфейса View.
 *
 * Используется для унифицированной передачи результата выполнения операций.
 * Все функции, возвращающие ViewResult_t, должны гарантировать, что
 * возвращаемое значение совпадает с одним из элементов этого перечисления.
 *
 * @note Значения перечисления могут использоваться в условных выражениях:
 *       @code
 *       if (result != VIEW_OK) { ... }
 *       @endcode
 *
 * @note Реализация должна избегать передачи неизвестных значений
 *       (например, через приведение типа) — это приведёт к неопределённому поведению.
 */
typedef enum {
    VIEW_OK,              ///< Операция выполнена успешно
    VIEW_ERROR,           ///< Общая ошибка (недостаточно памяти, системная ошибка и т.д.)
    VIEW_INVALID_ID,      ///< Недопустимый идентификатор элемента (например, несуществующая зона)
    VIEW_BAD_DATA,        ///< Некорректные данные (NULL-указатель, неверный формат и т.д.)
    VIEW_NOT_INITIALIZED, ///< Контекст не инициализирован или равен NULL
    VIEW_NO_EVENT         ///< Событие ввода отсутствует (не ошибка, а состояние)
} ViewResult_t;

/**
 * @struct InputEvent_t
 * @brief Описывает событие ввода с клавиатуры.
 *
 * Структура используется функцией poll_input для передачи информации
 * о пользовательском вводе в контроллер. Событие считается валидным,
 * если возвращённый код результата — VIEW_OK.
 *
 * @var InputEvent_t::key_code
 *     Логический код клавиши. Может быть:
 *     - ASCII-символ (например, 'a', 'q')
 *     - Специальный код (например, KEY_LEFT, KEY_ENTER)
 *     Если событие отсутствует, поле игнорируется (должно быть 0).
 *
 * @var InputEvent_t::key_state
 *     Состояние клавиши:
 *     - 0: событие — однократное нажатие (первый фрейм удержания)
 *     - 1: клавиша удерживается (повторное срабатывание)
 *
 * @note Поле key_code не обязательно совпадает с отображаемым символом.
 *       Например, KEY_UP может быть отображён как 'w' по соглашению.
 *
 * @note Семантика key_state зависит от бэкенда. Некоторые терминалы
 *       не поддерживают авто-повтор, тогда key_state всегда 0.
 */
typedef struct {
    int key_code;
    int key_state;
} InputEvent_t;

/**
 * @enum ElementType_t
 * @brief Тип данных, который должен быть отрисован в зоне интерфейса.
 *
 * Определяет, как интерпретировать поле content в структуре ElementData_t.
 * Каждому типу соответствует определённая ветвь union.
 *
 * @note Порядок значений важен для внутренней валидации:
 *       реализация может использовать проверку диапазона (например, type < ELEMENT_INVALID).
 * @note Если type имеет недопустимое значение, поведение draw_element не определено.
 */
typedef enum {
    ELEMENT_TEXT,   ///< const char* — строка с поддержкой '\n' (до 512 байт)
    ELEMENT_NUMBER, ///< int — целое число
    ELEMENT_MATRIX  ///< двумерный массив int (через content.matrix)
} ElementType_t;

/**
 * @struct ElementData_t
 * @brief Универсальный контейнер для передачи данных в интерфейс отображения.
 *
 * Используется функцией draw_element для передачи данных определённого типа.
 * Тип содержимого задаётся полем `type`, которое определяет, какая ветвь union используется.
 *
 * @var ElementData_t::type
 *     Тип данных, описываемых этой структурой. Должен быть одним из значений ElementType_t.
 *
 * @var ElementData_t::content
 *     Анонимный union, содержащий данные в зависимости от типа:
 *     - ELEMENT_TEXT:   текстовая строка (content.text)
 *     - ELEMENT_NUMBER: целое число (content.number)
 *     - ELEMENT_MATRIX: матрица (content.matrix.data, width, height)
 *
 * @note Память, на которую указывает content.matrix.data, не копируется.
 *       Вызывающий обязан обеспечить её валидность до вызова render().
 *
 * @note Массив в content.matrix хранится в row-major порядке:
 *       элемент (x, y) → индекс = y * width + x.
 *
 * @note Максимальная длина строки (content.text) — 512 байта, включая '\0'.
 *       Строки длиннее обрезаются.
 *
 * @note Поведение не определено, если type имеет недопустимое значение.
 */
typedef struct ElementData_t {
    ElementType_t type;
    union {
        const char *text;      ///< Текст для вывода (поддерживает '\n')
        int         number;    ///< Число для отображения
        struct {               ///< Матрица ячеек (например, игровое поле)
            const int *data;   ///< Указатель на данные (row-major)
            int        width;  ///< Ширина матрицы в ячейках
            int        height; ///< Высота матрицы в ячейках
        } matrix;
    } content;
} ElementData_t;

/**
 * @struct ColorPair_t
 * @brief Описывает цветовую пару: цвет текста и цвет фона.
 *
 * Используется для настройки цветового оформления элементов интерфейса.
 * Конкретные значения цветов зависят от реализации (бэкенда):
 * - В ncurses: номера цветовых пар, определённые через init_pair()
 * - В других системах: может быть RGB, индекс палитры и т.д.
 *
 * @var ColorPair_t::foreground
 *     Цвет переднего плана (текста или символа).
 *     Значение 0 обычно означает "по умолчанию".
 *
 * @var ColorPair_t::background
 *     Цвет фона.
 *     Значение 0 обычно означает "прозрачный" или "стандартный фон".
 *
 * @note Поведение не определено, если цвета не были предварительно инициализированы
 *       в используемом бэкенде (например, не вызвана init_pair() в ncurses).
 *
 * @note Цвета могут игнорироваться, если терминал или система отображения
 *       не поддерживает цветной вывод (режим монохромного отображения).
 */
typedef struct {
    int foreground; ///< Цвет текста/символа (0 = по умолчанию)
    int background; ///< Цвет фона (0 = стандартный)
} ColorPair_t;

/**
 * @brief Главный интерфейс представления (аналог vtable).
 *
 * Определяет набор функций, которые должна реализовать каждая графическая подсистема
 * (CLI, GUI, Web и др.). Все функции работают через абстрактный ViewHandle_t.
 *
 * Реализация обязана экспортировать константный экземпляр этой структуры,
 * например: `extern const ViewInterface cli_view;`
 *
 * @note Поле version должно быть установлено в VIEW_INTERFACE_VERSION
 *       для обеспечения совместимости.
 *
 * @note Указатели на функции не должны быть NULL — поведение не определено.
 *
 * @note Структура несёт версионность и не должна изменяться в обратно
 *       несовместимом виде. Новые версии могут добавлять поля в конец.
 *
 * Пример использования:
 * @code
 * ViewHandle_t handle = view_impl.init(10, 20, 30);
 * if (!handle) { 
 *   // обработка ошибки 
 * }
 *
 * view_impl.configure_zone(handle, "field", 1, 1, 10, 20);
 * // ... рисуем, обновляем, читаем ввод
 * view_impl.shutdown(handle);
 * @endcode
 */
typedef struct ViewInterface {
    int version; ///< Версия интерфейса. Должна быть равна VIEW_INTERFACE_VERSION.

    /**
     * @brief Инициализирует движок отображения.
     *
     * Выделяет и возвращает контекст представления. Инициализирует внутренние
     * ресурсы (например, графический режим, окно, цвета). Должна быть вызвана
     * первой перед использованием других функций интерфейса.
     *
     * @param width  Ширина игрового поля в символах (должна быть > 0)
     * @param height Высота игрового поля в символах (должна быть > 0)
     * @param fps    Частота обновления кадров (в кадрах в секунду, >= 1)
     * @return       Указатель на валидный ViewHandle_t при успехе,
     *               NULL — если инициализация failed (например, нет ресурсов,
     *               невозможна инициализация ncurses, ошибка выделения памяти).
     *
     * @note Повторный вызов init с тем же или другим handle не определён —
     *       должен вызываться только один раз на экземпляр интерфейса.
     * @note Возвращаемый handle должен передаваться во все последующие вызовы.
     * @note Если функция возвращает NULL, все последующие вызовы (кроме shutdown)
     *       с этим handle будут иметь неопределённое поведение.
     */
    ViewHandle_t (*init)(int width, int height, int fps);

    /**
     * @brief Настраивает зону вывода для элемента интерфейса.
     *
     * Определяет прямоугольную область на экране, в которой будет отображаться
     * элемент с заданным идентификатором. Если зона с таким идентификатором
     * уже существует, она заменяется новой конфигурацией.
     *
     * @param handle       Контекст представления (не должен быть NULL)
     * @param element_id   Имя зоны — строка до 15 символов (без учёта '\0').
     *                     Должна быть ненулевой и не пустой строкой.
     * @param x            Координата X левого верхнего угла (в символах, >= 1)
     * @param y            Координата Y левого верхнего угла (в символах, >= 1)
     * @param max_width    Максимальная ширина зоны (в символах, >= 1)
     * @param max_height   Максимальная высота зоны (в символах, >= 1)
     *
     * @return
     *         - VIEW_OK — зона успешно настроена
     *         - VIEW_NOT_INITIALIZED — handle равен NULL
     *         - VIEW_BAD_DATA — один из параметров (x, y, ширина, высота) некорректен,
     *                           или element_id — NULL или пустая строка
     *         - VIEW_ERROR — превышено максимальное количество зон (ограничено реализацией)
     *
     * @note Координаты отсчитываются от 1 (не от 0), чтобы оставить место
     *       для рамки и подписи при отрисовке (например, рамка строится от x-1, y-1).
     *       Использование x=0 или y=0 может привести к выходу за границы экрана.
     *
     * @note Рекомендуется вызывать configure_zone до начала отрисовки,
     *       чтобы избежать неопределённого поведения при draw_element.
     */
    ViewResult_t (*configure_zone)(ViewHandle_t handle,
                                   const char   *element_id,
                                   int           x,
                                   int           y,
                                   int           max_width,
                                   int           max_height);

    /**
     * @brief Отрисовывает данные в буфер заданной зоны.
     *
     * Подготавливает содержимое для отображения в ранее настроенной зоне.
     * Операция происходит в памяти (в буфере ncurses), физическое отображение
     * на экране выполняется только после вызова render().
     *
     * @param handle       Контекст представления. Не должен быть NULL.
     * @param element_id   Идентификатор зоны, ранее настроенной через configure_zone.
     *                     Должен соответствовать существующему имени зоны.
     * @param data         Указатель на данные для отрисовки. Не должен быть NULL.
     *
     * @return
     *         - VIEW_OK — отрисовка выполнена успешно
     *         - VIEW_NOT_INITIALIZED — handle равен NULL
     *         - VIEW_INVALID_ID — зона с таким element_id не найдена
     *         - VIEW_BAD_DATA — data == NULL, или type имеет недопустимое значение,
     *                           или для ELEMENT_MATRIX указан data->content.matrix.data == NULL
     *
     * @note Поле data->type должно корректно соответствовать используемому полю
     *       в union content. Например, при type == ELEMENT_TEXT,
     *       должен быть заполнен content.text.
     *
     * @note Отображение ненулевых значений для ELEMENT_MATRIX 
     *       зависит от реализации интерфеса.
     *
     * @note Вызов draw_element до configure_zone приведёт к VIEW_INVALID_ID.
     */
    ViewResult_t (*draw_element)(ViewHandle_t          handle,
                                 const char            *element_id,
                                 const ElementData_t   *data);

    /**
     * @brief Отображает содержимое буфера на экране.
     *
     * Применяет все изменения, накопленные через draw_element, и обновляет
     * физическое отображение на экране. Операция может быть ресурсоёмкой —
     * вызывайте её не чаще, чем с частотой, указанной в init (fps).
     *
     * @param handle Контекст представления. Не должен быть NULL.
     *
     * @return
     *         - VIEW_OK — обновление выполнено успешно
     *         - VIEW_NOT_INITIALIZED — handle равен NULL
     *
     * @note Функция является точкой синхронизации: после её вызова
     *       буфер считается "очищенным" для последующих изменений.
     *
     * @note Если вызвать render() без предварительных draw_element,
     *       обновление всё равно произойдёт — но видимых изменений не будет.
     *
     * @note Реализация может использовать wrefresh() (в ncurses) или аналоги —
     *       поведение зависит от реализации.
     */
    ViewResult_t (*render)(ViewHandle_t handle);

    /**
     * @brief Считывает одно событие ввода с устройства (например, клавиатуры).
     *
     * Функция не блокирует выполнение — возвращает результат немедленно.
     * Если событие доступно, оно записывается в *event, и функция возвращает VIEW_OK.
     * Если событий нет, возвращает VIEW_NO_EVENT, а содержимое *event не изменяется.
     *
     * @param [in] handle Контекст представления. Не должен быть NULL.
     * @param [in,out] event  Указатель на структуру, куда будет записано событие.
     *               Должен быть валидным указателем (не NULL).
     *
     * @return
     *         - VIEW_OK — событие успешно прочитано, *event заполнено
     *         - VIEW_NO_EVENT — событий нет (не ошибка)
     *         - VIEW_NOT_INITIALIZED — handle равен NULL
     *         - VIEW_ERROR — event равен NULL (недопустимый аргумент)
     *
     * @note Поведение key_state зависит от реализации:
     *       - 0: однократное нажатие (первое появление клавиши)
     *       - 1: удержание (повторное срабатывание, например, auto-repeat)
     *
     * @note Некоторые бэкенды (например, терминалы без поддержки авто-повтора)
     *       могут всегда возвращать key_state = 0.
     *
     * @note Рекомендуется вызывать poll_input на каждом кадре,
     *       чтобы не пропустить пользовательский ввод.
     */
    ViewResult_t (*poll_input)(ViewHandle_t handle, InputEvent_t *event);

    /**
     * @brief Завершает работу интерфейса и освобождает все связанные ресурсы.
     *
     * Деинициализирует графическую подсистему (например, завершает режим ncurses),
     * освобождает память, связанную с контекстом, и закрывает устройства ввода/вывода при необходимости.
     * После вызова handle становится недействительным и не должен использоваться.
     *
     * @param handle Контекст представления. Может быть NULL (вызов игнорируется).
     *
     * @return
     *         - VIEW_OK — деинициализация прошла успешно
     *         - VIEW_ERROR — произошла ошибка при освобождении ресурсов
     *           (например, ошибка завершения графического режима)
     *
     * @note Функция безопасна к многократному вызову, в том числе с NULL.
     *       Повторный вызов с тем же handle может вернуть VIEW_ERROR или быть проигнорирован —
     *       поведение зависит от реализации.
     *
     * @note Даже при возврате VIEW_ERROR, handle считается недействительным —
     *       нельзя пытаться использовать или повторно освобождать его.
     *
     * @note shutdown должен быть вызван ровно один раз на валидный handle,
     *       чтобы избежать утечек или двойного освобождения.
     */
    ViewResult_t (*shutdown)(ViewHandle_t handle);
} ViewInterface;

/**
 * @def VIEW_INTERFACE_VERSION
 * @brief Текущая версия интерфейса API представления.
 *
 * Используется для контроля совместимости между модулем View и его реализациями.
 * Реализации должны устанавливать это значение в поле .version структуры ViewInterface.
 *
 * @note При изменении сигнатур функций или структур — версия должна быть увеличена.
 * @note Код, использующий интерфейс, может проверять version для поддержки
 *       нескольких версий API или отказа при несовместимости.
 */
#define VIEW_INTERFACE_VERSION 1

#ifdef __cplusplus
}
#endif

#endif // VIEW_H

/** @} */  // end of View module