/**
 * @file s21_snake_internals.hpp
 * @brief Внутренний интерфейс модели игры "Змейка" на C++17
 *
 * Объявляет классы, типы, константы и методы, реализующие логику игры "Змейка"
 * в пространстве имён s21. Файл предназначен **исключительно** для
 * использования в реализации C API (s21_snake.cpp) и **не должен** включаться
 * извне.
 *
 * @note Данный заголовок — часть приватной реализации. Не включать в публичные
 *       интерфейсы или сторонние модули.
 *
 * @warning Изменения в объявлениях классов, сигнатурах методов или структуре
 *          данных **требуют синхронизации** с:
 *          - реализацией в s21_snake_internals.cpp
 *          - C API обёрткой в s21_snake.cpp
 *          - ABI совместимостью с движком s21_bgame
 *
 * @warning Не допускается изменение порядка enum-ов (SnakeState, SnakeEvent,
 * Direction) — нарушение приведёт к сбоям в работе FSM или сериализации.
 *
 * Архитектурные особенности:
 * - Пространство имён: s21
 * - Управление состоянием через FSM с использованием enum class
 * - Использование современных контейнеров: std::deque (тело змейки),
 * std::unordered_set (занятые ячейки)
 * - Непрозрачный указатель (void*) для инкапсуляции реализации от C API
 * - Все методы и функции помечены как noexcept — исключения не пересекают
 * границу C/C++
 * - Потокобезопасность не реализована — весь API предполагает однопоточное
 * использование
 *
 * Ключевые компоненты:
 * - SnakeState    — состояния игры (INIT, MOVE, PAUSED, GAME_OVER)
 * - SnakeEvent    — события для конечного автомата (START, PAUSE_TOGGLE,
 * MOVE_*, и др.)
 * - Direction     — направления движения (UP, DOWN, LEFT, RIGHT)
 * - SnakeSegment  — POD-структура для координат сегмента змейки
 * - SnakeGame     — основной класс, инкапсулирующий всю игровую логику
 *
 * @note Реализация использует возможности C++17:
 *       std::deque, std::unordered_set, thread_local, std::mt19937, enum class,
 * constexpr.
 *
 * @note Генерация яблок оптимизирована: используется std::unordered_set для
 *       быстрого поиска занятых ячеек и std::vector для сбора свободных.
 *
 * @author provemet
 * @version 1.0
 * @date 2025-12-26
 * @see s21_snake_internals.cpp — реализация класса SnakeGame
 * @see s21_snake.cpp — C API обёртка
 * @see s21_snake.h — публичный C интерфейс
 */

#pragma once

#include <array>
#include <cstdint>
#include <cstdlib>
#include <deque>
#include <unordered_set>

#include "s21_bgame.h"
#include "s21_fsm.h"

namespace s21 {

/**
 * @brief Высота игрового поля в строках (по умолчанию — 20).
 *
 * Задаёт вертикальный размер игрового поля — количество строк, в которых
 * движется змейка. Используется для:
 * - выделения памяти под массив info_.field
 * - проверки выхода за границы при движении
 * - инициализации начальной позиции змейки и генерации яблока
 *
 * @warning Значение должно быть положительным целым числом.
 *          Изменение может нарушить баланс игры и требует синхронизации с:
 *          - логикой отрисовки (рендерер должен поддерживать новый размер)
 *          - генерацией яблока (свободные ячейки пересчитываются)
 *          - начальным размещением змейки (центр поля зависит от размера)
 *
 * @note Это constexpr-константа C++. Все расчёты с её участием выполняются на
 * этапе компиляции.
 * @note Изменение значения требует полной перекомпиляции проекта.
 *
 * @par Пример использования:
 * @code
 * // Инициализация игрового поля
 * for (int y = 0; y < SNAKE_FIELD_ROWS; ++y) {
 *     std::memset(info_.field[y], 0, SNAKE_FIELD_COLS * sizeof(int));
 * }
 *
 * // Проверка границ
 * if (head.y < 0 || head.y >= SNAKE_FIELD_ROWS) {
 *     return true; // Столкновение с границей
 * }
 * @endcode
 */
constexpr int SNAKE_FIELD_ROWS = BGAME_FIELD_HEIGHT;

/**
 * @brief Ширина игрового поля в столбцах (по умолчанию — 10).
 *
 * Задаёт горизонтальный размер игрового поля — количество столбцов, в которых
 * движется змейка. Используется для:
 * - выделения памяти под двумерный массив info_.field
 * - проверки выхода за левую/правую границу при движении
 * - позиционирования змейки по центру при инициализации
 * - генерации яблока на свободной ячейке
 * - расчёта занятых ячеек (через формулу y * SNAKE_FIELD_COLS + x)
 *
 * @warning Значение должно быть положительным целым числом.
 *          Изменение может повлиять на:
 *          - баланс и сложность игры (меньше места — сложнее играть)
 *          - логику генерации яблок (особенно при значении >255 — риск
 * переполнения индекса)
 *          - отрисовку (визуальный интерфейс должен адаптироваться)
 *          - работу std::unordered_set (ключи ячеек зависят от ширины)
 *
 * @note Это constexpr-константа C++. Все зависимости обрабатываются на этапе
 * компиляции.
 * @note Изменение требует полной перекомпиляции проекта и тестирования
 * граничных случаев.
 *
 * @par Пример использования:
 * @code
 * // Инициализация строки поля
 * for (int x = 0; x < SNAKE_FIELD_COLS; ++x) {
 *     info_.field[0][x] = 0;
 * }
 *
 * // Проверка горизонтальных границ
 * if (head.x < 0 || head.x >= SNAKE_FIELD_COLS) {
 *     return true; // Столкновение с боковой стенкой
 * }
 *
 * // Расчёт ключа ячейки для std::unordered_set
 * int cell_key = head.y * SNAKE_FIELD_COLS + head.x;
 * occupied_cells_.insert(cell_key);
 * @endcode
 */
constexpr int SNAKE_FIELD_COLS = BGAME_FIELD_WIDTH;

/**
 * @brief Максимально возможная длина змейки в сегментах (по умолчанию — 200).
 *
 * Задаёт верхнюю границу количества сегментов змейки, равную полному заполнению
 * игрового поля размером SNAKE_FIELD_ROWS × SNAKE_FIELD_COLS (20 × 10 = 200).
 * Используется как:
 * - условие максимального размера (защита от переполнения памяти и логических
 * ошибок)
 * - ограничение для генерации яблок (если змейка заполнила всё поле — нельзя
 * сгенерировать яблоко)
 * - потенциальный триггер для "победы" (если реализовано в логике)
 * - ограничитель для выделения ресурсов (например, отрисовка хвоста)
 *
 * @warning Значение должно быть положительным и не превышать
 *          SNAKE_FIELD_ROWS * SNAKE_FIELD_COLS. Нарушение может привести к:
 *          - логическим ошибкам (попытка сгенерировать яблоко на заполненном
 * поле)
 *          - нарушению инвариантов игры
 *          - неопределённому поведению при проверках длины
 *
 * @note Значение вычисляется как произведение SNAKE_FIELD_ROWS и
 * SNAKE_FIELD_COLS — при изменении размеров поля SNAKE_MAX_LENGTH **должно быть
 * пересчитано**.
 * @note Используется в методах, проверяющих возможность продолжения игры.
 * @note Является constexpr — доступно на этапе компиляции.
 *
 * @par Пример использования:
 * @code
 * // Проверка условия завершения игры (полное заполнение поля)
 * if (snake.getLength() >= SNAKE_MAX_LENGTH) {
 *     snake_set_state(game, GAME_OVER);
 *     info_.score = info_.high_score = 99999; // Особая награда за победу
 * }
 *
 * // Проверка перед генерацией нового яблока
 * if (occupied_cells_count >= SNAKE_MAX_LENGTH - 1) {
 *     // На поле нет свободных ячеек — игра завершается
 *     return;
 * }
 * @endcode
 */
constexpr int SNAKE_MAX_LENGTH = 200;

/**
 * @brief Начальная длина змейки при старте новой игры (по умолчанию — 3).
 *
 * Определяет количество сегментов, с которыми змейка появляется на поле после
 * инициализации или перезапуска (в состояниях INIT → MOVE).
 *
 * Стандартное значение (3) обеспечивает:
 * - достаточную сложность с самого начала
 * - возможность поворота без немедленного столкновения
 * - визуально сбалансированное начальное положение
 *
 * Используется в методах:
 * - initializeSnake_() — формирование начального тела
 * - reset() — восстановление состояния при новой игре
 * - spawn() — размещение на поле с учётом центра и направления
 *
 * @warning Значение должно быть:
 *          - положительным (≥ 1)
 *          - не превышать SNAKE_MAX_LENGTH
 *          - не выходить за левую/правую границу при размещении (например,
 * start_x - (len-1) ≥ 0) Нарушение может привести к:
 *          - змее, выходящей за пределы поля
 *          - переполнению или сбою в инициализации
 *          - невозможности начать игру
 *
 * @note При изменении значения убедитесь, что:
 *       - начальная позиция (центр поля) позволяет разместить всю змейку
 *       - логика движения не полагается жёстко на длину 3
 *       - тесты покрывают новые краевые случаи
 *
 * @par Пример использования:
 * @code
 * void SnakeGame::initializeSnake_() noexcept {
 *     body_.clear();
 *     const int start_x = SNAKE_FIELD_COLS / 2;
 *     const int start_y = SNAKE_FIELD_ROWS / 2;
 *
 *     // Создание змейки длиной SNAKE_INITIAL_LENGTH, тянущейся влево от центра
 *     for (int i = 0; i < SNAKE_INITIAL_LENGTH; ++i) {
 *         body_.push_back(SnakeSegment(start_x - i, start_y));
 *     }
 *
 *     direction_ = Direction::RIGHT;
 *     next_direction_ = Direction::RIGHT;
 * }
 * @endcode
 */
constexpr int SNAKE_INITIAL_LENGTH = 3;

/**
 * @brief Имя директории для хранения файлов рекордов игры (по умолчанию —
 * ".brickgame").
 *
 * Определяет имя **скрытой** директории в домашней папке пользователя,
 * используемой для хранения файлов с рекордами и другим пользовательским
 * состоянием игры.
 *
 * Стандартные пути:
 * - Unix-подобные системы (Linux, macOS): `~/.brickgame`
 * - Windows: `%USERPROFILE%\\.brickgame`
 *
 * Директория создаётся автоматически при первом обращении, если не существует.
 * Это соответствует конвенциям хранения пользовательских данных:
 * - на Unix — XDG Base Directory (упрощённая форма)
 * - на Windows — стандартный путь профиля пользователя
 *
 * Используется в функциях:
 * - loadHighScore() — загрузка рекорда при запуске
 * - saveHighScore() — сохранение рекорда при выходе или game over
 * - ensureSaveDirExists() — проверка и создание директории
 *
 * @warning Значение должно быть:
 *          - строковым литералом (C-style string)
 *          - не изменяться во время выполнения
 *          - не содержать недопустимых символов для путей (('/', '\\', ':',
 * '*', '?', '"', '<', '>', '|')) на целевых платформах
 *
 * @note Приложение требует прав на:
 *       - чтение (для загрузки рекорда)
 *       - запись и создание директории (для инициализации и сохранения)
 *       Отсутствие прав приведёт к отключению сохранения рекорда.
 *
 * @note Использование скрытой директории (с префиксом '.') соответствует
 *       стандартам Unix и уменьшает шум в домашней папке.
 *
 * @par Пример использования:
 * @code
 * std::string getConfigDir() {
 *     std::string home = getHomeDir();
 *     if (home.empty()) return {};
 *     std::string config_path = home + SNAKE_SCORE_DIR; // Рекомендуется
 * использовать SNAKE_SCORE_DIR ensureDirectoryExists(config_path); // Создаёт
 * путь, если не существует return config_path;
 * }
 * @endcode
 */
constexpr const char* SNAKE_SCORE_DIR = BGAME_SCORE_DIR;

/**
 * @brief Полный путь к файлу сохранения рекорда игры "Змейка".
 *
 * Определяет полный путь к файлу, в котором сохраняется рекорд игрока между
 * сессиями. Файл размещается в директории, указанной в SNAKE_SCORE_DIR
 * (например, ~/.brickgame/snake).
 *
 * Используется в приватных методах:
 * - loadHighScore_() — загрузка рекорда при запуске игры
 * - saveHighScore_() — сохранение рекорда при выходе или достижении нового
 * максимума
 *
 * Примеры полных путей:
 * - Linux/macOS: `/home/user/.brickgame/snake` или
 * `/Users/user/.brickgame/snake`
 * - Windows: `C:\Users\user\.brickgame\snake`
 *
 * @warning
 * - Приложение требует прав на чтение и запись в этот файл.
 * - На Unix-подобных системах имя файла чувствительно к регистру.
 * - На Windows возможно кэширование доступа к файлу — избегайте одновременной
 * записи из нескольких процессов.
 * - Значение определено как строковый литерал — **не изменяйте его во время
 * выполнения**.
 *
 * @note Файл содержит только одно значение — целое число (high score) в
 * текстовом формате. Пустой или отсутствующий файл интерпретируется как рекорд
 * = 0.
 *
 * @note Рекомендуется использовать атомарные операции при записи:
 *       сначала записать во временный файл, затем переименовать — это
 * предотвращает повреждение данных при сбое во время сохранения.
 *
 * @note Убедитесь, что родительская директория (SNAKE_SCORE_DIR) создана до
 * попытки чтения/записи. Используйте ensureSaveDirExists() или аналог перед
 * обращением к файлу.
 *
 * @par Пример использования:
 * @code
 * std::ifstream file(SNAKE_SCORE_FILE);
 * if (file.is_open()) {
 *     int loaded_score;
 *     if (file >> loaded_score && loaded_score >= 0) {
 *         high_score_ = loaded_score;
 *     }
 *     file.close();
 * }
 * // Если файл не существует или повреждён — high_score_ остаётся по умолчанию
 * (0)
 * @endcode
 */
constexpr const char* SNAKE_SCORE_FILE = BGAME_SCORE_DIR "/snake.score";

/**
 * @brief Значение, используемое в info_.field для обозначения яблока
 *
 * Устанавливается в ячейку игрового поля (field[y][x]), где находится яблоко.
 * Используется функцией отрисовки для визуального отображения еды.
 *
 * @note Выбрано значение 3, чтобы избежать конфликта с номерами сегментов
 * змейки:
 *       - 0: пустая ячейка
 *       - 1: тело змейки
 *       - 2: голова змейки
 *
 * @warning Не изменяйте это значение без синхронного обновления логики
 * отрисовки и проверок на яблоко (например, в методах handleAppleEaten_()).
 *          Несогласованное значение приведёт к игнорированию яблок или
 * визуальным багам.
 *
 * @par Пример использования:
 * @code
 * // Установка яблока на поле
 * info_.field[apple_y][apple_x] = SNAKE_APPLE_CELL;
 *
 * // Проверка, съедено ли яблоко
 * if (info_.field[head.y][head.x] == SNAKE_APPLE_CELL) {
 *     handleAppleEaten_();
 * }
 * @endcode
 */
constexpr int SNAKE_APPLE_CELL = 3;

/**
 * @brief Значение, используемое в info_.field для обозначения головы змейки
 *
 * Устанавливается в ячейку игрового поля (field[y][x]), где находится голова
 * змейки. Используется функциями отрисовки для визуального выделения головы.
 *
 * @note Выбрано значение 2, чтобы отличать от:
 *       - 0: пустая ячейка
 *       - 1: тело змейки
 *       - 3: яблоко
 *
 * @warning Не изменяйте это значение без синхронного обновления логики
 * отрисовки и проверок столкновений. Несогласованное значение приведёт к
 * визуальным багам или некорректной обработке игровых событий.
 *
 * @par Пример использования:
 * @code
 * // Установка головы змейки на поле
 * info_.field[head.y][head.x] = SNAKE_HEAD_CELL;
 *
 * // Проверка позиции головы при отладке
 * if (info_.field[y][x] == SNAKE_HEAD_CELL) {
 *     drawHead(x, y);
 * }
 * @endcode
 */
constexpr int SNAKE_HEAD_CELL = 2;

/**
 * @brief Значение, используемое в info_.field для обозначения сегмента тела
 * змейки
 *
 * Устанавливается в ячейки игрового поля (field[y][x]), занятые телом змейки
 * (все сегменты, кроме головы). Используется функциями отрисовки для
 * визуального отображения тела.
 *
 * @note Выбрано значение 1, чтобы отличать от:
 *       - 0: пустая ячейка
 *       - 2: голова змейки
 *       - 3: яблоко
 *
 * @warning Не изменяйте это значение без синхронного обновления логики
 * отрисовки и проверок столкновений с телом. Несогласованное значение может
 * привести к игнорированию столкновений или визуальным артефактам.
 *
 * @par Пример использования:
 * @code
 * // Заполнение поля для отрисовки тела змейки
 * for (const auto& segment : snakeBody) {
 *     info_.field[segment.y][segment.x] = SNAKE_BODY_CELL;
 * }
 *
 * // Проверка столкновения с телом (кроме головы)
 * if (info_.field[pos.y][pos.x] == SNAKE_BODY_CELL) {
 *     setGameState(GAME_OVER);
 * }
 * @endcode
 */
constexpr int SNAKE_BODY_CELL = 1;

/**
 * @enum SnakeState
 * @brief Состояния конечного автомата (FSM) игры "Змейка"
 *
 * Определяет все возможные состояния жизненного цикла игры, используемые для
 * управления логикой переходов между режимами. Каждое состояние задаёт
 * поведение игры при обработке ввода и обновлении.
 *
 * Возможные значения:
 * - INIT      — начальное состояние, до запуска игры (отображается стартовый
 * экран)
 * - MOVE      — активная игра, змейка движется, игрок управляет направлением
 * - PAUSED    — игра приостановлена, игровое поле заморожено, ожидается
 * продолжение
 * - GAME_OVER — завершение игры (змейка столкнулась), отображается финальный
 * экран
 * - MAX       — служебное значение, указывает количество состояний; не
 * используется как состояние
 *
 * @note Используется как базовый тип для индексации таблиц переходов или
 * массивов состояний.
 * @note Тип: `std::uint8_t` — выбран для компактности (малое количество
 * состояний).
 * @note Все переходы между состояниями управляются в методе `handleEvent_()`.
 * @note Значение `MAX` позволяет легко определять размер FSM без дублирования
 * констант.
 *
 * @warning Новые состояния **должны добавляться перед `MAX`** — порядок
 * критичен.
 * @warning Не разрешается удалять или переупорядочивать существующие значения —
 *          это нарушит логику переходов и сериализацию (если реализована).
 * @warning Значение `MAX` **не должно использоваться** как реальное состояние
 * игры.
 *
 * @par Пример использования:
 * @code
 * void SnakeGame::handleEvent_(SnakeEvent event) noexcept {
 *     switch (state_) {
 *         case SnakeState::INIT:
 *             if (event == SnakeEvent::START) {
 *                 state_ = SnakeState::MOVE;
 *                 spawn();
 *             }
 *             break;
 *         case SnakeState::MOVE:
 *             if (event == SnakeEvent::PAUSE_TOGGLE) {
 *                 state_ = SnakeState::PAUSED;
 *             }
 *             break;
 *         case SnakeState::PAUSED:
 *             if (event == SnakeEvent::PAUSE_TOGGLE) {
 *                 state_ = SnakeState::MOVE;
 *             }
 *             break;
 *         case SnakeState::GAME_OVER:
 *             if (event == SnakeEvent::START) {
 *                 state_ = SnakeState::MOVE;
 *                 reset();
 *             }
 *             break;
 *         default:
 *             break;
 *     }
 * }
 * @endcode
 */
enum class SnakeState : int {
  INIT = 0,  ///< Инициализация игры — начальное состояние, ожидание старта
  MOVE,  ///< Активное движение змейки — основной игровой режим
  PAUSED,  ///< Пауза — игра приостановлена, обновления не происходят
  GAME_OVER,  ///< Состояние окончания игры — отображение результатов
  MAX  ///< Служебное значение: количество состояний (для итераций)
};

/**
 * @enum SnakeEvent
 * @brief Типы событий конечного автомата (FSM) игры "Змейка"
 *
 * Определяет события, вызывающие переходы между состояниями игры. Каждое
 * событие может быть сгенерировано:
 * - пользовательским вводом (клавиши, тач)
 * - внутренней логикой игры (таймер, завершение анимации)
 * - системными вызовами (C API через snake_handle_input)
 *
 * Возможные значения:
 * - NONE         — пустое или игнорируемое событие
 * - START        — запуск новой игры (из INIT или GAME_OVER)
 * - PAUSE_TOGGLE — переключение режима паузы (активно в состоянии MOVE)
 * - MOVE_LEFT    — попытка изменения направления влево
 * - MOVE_RIGHT   — попытка изменения направления вправо
 * - MOVE_UP      — попытка изменения направления вверх
 * - MOVE_DOWN    — попытка ускоренного движения вниз
 * - TERMINATE    — немедленное завершение игры
 * - MAX          — служебное значение; количество событий, не используется как
 * событие
 *
 * @note Используется в методе dispatchEvent_() для маршрутизации в обработчики.
 * @note Тип: int — выбран для:
 *        - совместимости с C API (UserAction_t)
 *        - возможности расширения за счёт отрицательных кодов (например,
 * системные события)
 *        - избежания неявных приведений при сравнении
 * @note Значение `MAX` позволяет легко определять размер таблицы событий.
 * @note События `MOVE_*` обрабатываются только в состоянии `MOVE` и не вызывают
 *       немедленного движения — направление фиксируется и применяется при
 * следующем тике.
 *
 * @warning Порядок значений **должен сохраняться** — некоторые реализации могут
 *          использовать индексацию или таблицы переходов.
 * @warning Новые события **должны добавляться перед `MAX`**.
 * @warning Значение `MAX` **не должно использоваться** как реальное событие.
 * @warning Изменение списка требует обновления mapActionToEvent_() и
 * FSM-логики.
 *
 * @par Пример использования:
 * @code
 * SnakeEvent event = mapActionToEvent_(action);
 * if (event != SnakeEvent::NONE) {
 *     dispatchEvent_(event);
 * }
 *
 * // Внутри dispatchEvent_
 * switch (event) {
 *     case SnakeEvent::START:
 *         if (state_ == SnakeState::INIT || state_ == SnakeState::GAME_OVER) {
 *             state_ = SnakeState::MOVE;
 *             reset();
 *         }
 *         break;
 *     case SnakeEvent::PAUSE_TOGGLE:
 *         if (state_ == SnakeState::MOVE) {
 *             state_ = SnakeState::PAUSED;
 *         } else if (state_ == SnakeState::PAUSED) {
 *             state_ = SnakeState::MOVE;
 *         }
 *         break;
 *     // ... остальные обработчики
 *     default:
 *         break;
 * }
 * @endcode
 */
enum class SnakeEvent : int {
  NONE = FSM_EVENT_NONE,  ///< Пустое событие — игнорируется диспетчером
  START,                  ///< Событие старта или перезапуска игры — переход в MOVE
  MOVE_LEFT,              ///< Попытка сдвинуть змейку влево — обрабатывается, если возможно
  MOVE_RIGHT,             ///< Попытка сдвинуть змейку вправо — обрабатывается, если
                          ///< возможно
  MOVE_DOWN,              ///< Попытка сдвинуть змейку вниз — может использоваться для
                          ///< ускорения
  MOVE_UP,                ///< Попытка сдвинуть змейку вверх — обрабатывается, если возможно
  PAUSE_TOGGLE,           ///< Переключение состояния паузы (вкл/выкл)
  TERMINATE,              ///< Принудительное завершение игры (выход)
  AUTO_RESET,             ///< Автоматический сброс игры
  MAX                     ///< Служебное значение: количество событий (для итераций)
};

/**
 * @enum Direction
 * @brief Направления движения змейки на игровом поле
 *
 * Определяет все возможные направления, в которых может перемещаться голова
 * змейки. Используется для:
 * - хранения текущего направления (direction_)
 * - буферизации следующего направления (next_direction_)
 * - обработки пользовательского ввода (повороты)
 *
 * Возможные значения:
 * - UP    — движение вверх (y уменьшается)
 * - DOWN  — движение вниз (y увеличивается)
 * - LEFT  — движение влево (x уменьшается)
 * - RIGHT — движение вправо (x увеличивается)
 *
 * @note Координатная система:
 *       - (0,0) — левый верхний угол поля
 *       - y: сверху вниз (вниз — увеличение)
 *       - x: слева направо (вправо — увеличение)
 *
 * @note Тип: int — выбран для:
 *       - избежания неявных приведений при работе с C API (UserAction_t)
 *       - удобства при отладке и логировании (значения читаются как числа)
 *       - совместимости с внешними интерфейсами и таблицами переходов
 *
 * @warning Запрещено мгновенное разворот на 180°:
 *          - UP ↔ DOWN
 *          - LEFT ↔ RIGHT
 *          Такие изменения направления **должны игнорироваться** логикой.
 *          Например, если текущее направление — UP, событие MOVE_DOWN не должно
 *          изменять direction_.
 *
 * @warning Направление изменяется только через очередь (next_direction_),
 *          чтобы избежать "врезания" в собственное тело при быстрых поворотах.
 *
 * @par Пример использования:
 * @code
 * void SnakeGame::move_() noexcept {
 *     if (body_.empty()) return;
 *
 *     SnakeSegment head = body_.front();
 *
 *     switch (direction_) {
 *         case Direction::UP:
 *             head.y--;
 *             break;
 *         case Direction::DOWN:
 *             head.y++;
 *             break;
 *         case Direction::LEFT:
 *             head.x--;
 *             break;
 *         case Direction::RIGHT:
 *             head.x++;
 *             break;
 *     }
 *
 *     // Проверка выхода за границы или столкновения с телом
 *     if (isCollision_(head)) {
 *         state_ = SnakeState::GAME_OVER;
 *         return;
 *     }
 *
 *     // Перемещение головы
 *     body_.push_front(head);
 *
 *     // Удаление хвоста (если не съедено яблоко)
 *     if (!appleEaten_) {
 *         body_.pop_back();
 *     } else {
 *         appleEaten_ = false;
 *         increaseScore_();
 *     }
 * }
 * @endcode
 */
enum class Direction : int {
  UP = 0,  ///< Вверх (y--)
  DOWN,    ///< Вниз (y++)
  LEFT,    ///< Влево (x--)
  RIGHT    ///< Вправо (x++)
};

/**
 * @internal
 * @brief Приводит внутреннее состояние игры к типу конечного автомата
 * (fsm_state_t)
 * @param s Значение из перечисления SnakeState
 * @return Соответствующее значение типа fsm_state_t, совместимое с C-уровнем
 * FSM
 *
 * Выполняет безопасное преобразование перечисления C++ (class enum) SnakeState
 * в C-совместимый тип fsm_state_t, используемый в реализации конечного
 * автомата.
 *
 * Используется для интеграции C++ логики с C-совместимым FSM, обеспечивая:
 * - типобезопасность на уровне C++
 * - обратную совместимость с C API
 * - прозрачное взаимодействие с таблицей переходов (transitions_)
 *
 * @note Функция помечена как inline — встраивается для минимизации накладных
 * расходов.
 * @note Не выбрасывает исключения — noexcept гарантирует совместимость с C.
 * @note Должна использоваться при всех переходах между C++ и FSM-движком.
 *
 * @warning Убедитесь, что значения SnakeState и fsm_state_t остаются
 * синхронизированными. При добавлении новых состояний требуется обновление
 * обоих типов.
 *
 * @par Пример использования:
 * @code
 * fsm_.current = to_fsm_state(SnakeState::MOVE);
 * // или в таблице переходов:
 * {to_fsm_state(SnakeState::INIT), to_fsm_event(SnakeEvent::START), ...}
 * @endcode
 */
inline fsm_state_t to_fsm_state(SnakeState s) noexcept {
  return static_cast<fsm_state_t>(s);
}

/**
 * @internal
 * @brief Преобразует состояние FSM обратно в внутреннее перечисление игры
 * @param s Значение типа fsm_state_t, используемое в конечном автомате
 * @return Соответствующее значение из перечисления SnakeState
 *
 * Выполняет обратное преобразование C-совместимого состояния (fsm_state_t)
 * в тип C++ (SnakeState), используемый внутри класса SnakeGame.
 *
 * Необходима для:
 * - извлечения текущего состояния из FSM (fsm_.current)
 * - интерпретации состояния в C++-методах (например, в processEvent_)
 * - обеспечения совместимости между C API и внутренней логикой
 *
 * @note Функция помечена как inline — встраивается для минимизации накладных
 * расходов.
 * @note Не выбрасывает исключения — noexcept гарантирует совместимость с C.
 * @note Используется в паре с to_fsm_state() для двустороннего преобразования.
 *
 * @warning Не проверяет валидность входного значения — поведение не определено
 *          при передаче недопустимого состояния (например, из повреждённого
 * FSM).
 * @warning Убедитесь, что порядок элементов в SnakeState соответствует
 * ожиданиям FSM.
 *
 * @par Пример использования:
 * @code
 * SnakeState state = from_fsm_state(fsm_.current);
 * if (state == SnakeState::PAUSED) {
 *     // Обработка паузы
 * }
 * @endcode
 */
inline SnakeState from_fsm_state(fsm_state_t s) noexcept {
  return static_cast<SnakeState>(s);
}

/**
 * @internal
 * @brief Преобразует событие игры в тип, совместимый с конечным автоматом (FSM)
 * @param e Значение из перечисления SnakeEvent
 * @return Соответствующее значение типа fsm_event_t, используемое в
 * C-реализации FSM
 *
 * Выполняет безопасное приведение внутреннего C++ перечисления SnakeEvent
 * к C-совместимому типу fsm_event_t. Необходимо для интеграции C++ логики
 * с низкоуровневым конечным автоматом, который работает с C-типами.
 *
 * Используется при отправке событий в FSM, например:
 * - при обработке ввода (handle_input)
 * - при генерации таймера (TICK)
 * - при переходах состояний (например, TERMINATE)
 *
 * @note Функция помечена как inline — встраивается для минимизации накладных
 * расходов.
 * @note Не выбрасывает исключения — noexcept обеспечивает совместимость с C
 * API.
 * @note Должна использоваться при всех вызовах processEvent_ или в таблице
 * переходов.
 *
 * @warning Убедитесь, что значения SnakeEvent и fsm_event_t синхронизированы.
 *          Добавление нового события требует обновления обоих типов.
 * @warning Передача неизвестного значения приведёт к неопределённому поведению
 * FSM.
 *
 * @par Пример:
 * @code
 * fsm_event_t event = to_fsm_event(SnakeEvent::PAUSE_TOGGLE);
 * processEvent_(event);
 * @endcode
 */
inline fsm_event_t to_fsm_event(SnakeEvent e) noexcept {
  return static_cast<fsm_event_t>(e);
}

/**
 * @struct SnakeSegment
 * @brief Представляет один сегмент тела змейки в игре "Змейка"
 *
 * Хранит координаты (x, y) одного сегмента змейки на игровом поле.
 * Используется в качестве элемента контейнера `body_`, реализованного как
 * std::deque.
 *
 * @note Является POD-типом (Plain Old Data):
 *       - Поддерживает агрегатную инициализацию
 *       - Может быть безопасно копирован через memcpy (при необходимости)
 *       - Не имеет виртуальных функций, деструктора или управляющего кода
 *       - Гарантированно размещается компактно в памяти
 *
 * @note Координаты используют систему:
 *       - (0, 0) — левый верхний угол поля
 *       - x: увеличивается вправо (горизонталь)
 *       - y: увеличивается вниз (вертикаль)
 *
 * @note Ограничения диапазона:
 *       - x ∈ [0; SNAKE_FIELD_COLS - 1]
 *       - y ∈ [0; SNAKE_FIELD_ROWS - 1]
 *
 * @note В контейнере `body_`:
 *       - Первый элемент (front) — голова змейки
 *       - Последующие элементы — сегменты тела в порядке от головы к хвосту
 *       - Последний элемент (back) — конец хвоста
 *
 * @warning Запрещено создавать сегменты с координатами за пределами поля.
 *          Проверка границ должна выполняться в методе move_() перед
 * обновлением позиции.
 * @warning Не допускается наличие дублирующихся координат в `body_` — это
 * означает столкновение змейки с самой собой.
 *
 * @par Пример использования:
 * @code
 * std::deque<SnakeSegment> body_;
 *
 * // Инициализация начальной позиции (голова в центре)
 * const int start_x = SNAKE_FIELD_COLS / 2;
 * const int start_y = SNAKE_FIELD_ROWS / 2;
 * for (int i = 0; i < SNAKE_INITIAL_LENGTH; ++i) {
 *     body_.push_back(SnakeSegment{start_x - i, start_y});
 * }
 *
 * // Движение: добавление новой головы
 * SnakeSegment new_head = body_.front();
 * switch (direction_) {
 *     case Direction::RIGHT: new_head.x++; break;
 *     case Direction::LEFT:  new_head.x--; break;
 *     case Direction::DOWN:  new_head.y++; break;
 *     case Direction::UP:    new_head.y--; break;
 * }
 *
 * // Проверка на столкновение с границей или телом
 * if (isOutOfBounds(new_head) || containsSegment(body_, new_head)) {
 *     state_ = SnakeState::GAME_OVER;
 *     return;
 * }
 *
 * // Продвижение змейки
 * body_.push_front(new_head);
 * if (!appleEaten_) {
 *     body_.pop_back();  // Удаление хвоста, если яблоко не съедено
 * }
 * @endcode
 */
struct SnakeSegment {
  int x = 0;  ///< Горизонтальная координата (столбец) на игровом поле [0,
              ///< SNAKE_FIELD_COLS-1]
  int y = 0;  ///< Вертикальная координата (строка) на игровом поле [0,
              ///< SNAKE_FIELD_ROWS-1]

  /**
   * @brief Конструктор по умолчанию — инициализирует координаты нулями
   * @note Помечен как noexcept для безопасности при работе с контейнерами
   */
  SnakeSegment() noexcept = default;

  /**
   * @brief Конструктор с параметрами для инициализации координат
   * @param x_val Горизонтальная координата сегмента
   * @param y_val Вертикальная координата сегмента
   * @note Помечен как noexcept для безопасности при работе с контейнерами
   */
  SnakeSegment(int x_val, int y_val) noexcept : x(x_val), y(y_val) {}
};

/**
 * @class SnakeGame
 * @brief Основной класс, управляющий логикой игры "Змейка"
 *
 * Центральный компонент игры, реализующий полную игровую механику с
 * использованием конечного автомата (FSM). Контролирует:
 * - жизненный цикл игры (INIT → MOVE → PAUSED/GAME_OVER)
 * - движение, повороты и рост змейки
 * - генерацию яблок на свободных ячейках
 * - проверку столкновений с границами и собственным телом
 * - отслеживание счёта, уровня и скорости
 * - загрузку и сохранение рекорда между сессиями
 * - интеграцию с C API через статические методы
 *
 * Архитектура:
 * - Паттерн "непрозрачный указатель": экземпляр создаётся и уничтожается только
 *   через `create()` / `destroy()`, что обеспечивает инкапсуляцию C++
 * реализации.
 * - FSM на основе таблицы переходов — чёткое разделение состояний и событий.
 * - Использование эффективных контейнеров: `std::deque` для тела змейки,
 * `std::unordered_set` для ускорения проверки занятых ячеек.
 *
 * @note Класс не является потокобезопасным. Все вызовы API для одного
 * экземпляра должны происходить из одного и того же потока.
 * @note Все публичные методы помечены как `noexcept` — исключения C++ не
 * пересекают границу C API, что предотвращает `std::terminate()`.
 * @note Реализация скрыта от внешнего мира — пользователь работает только с
 * `void*`.
 *
 * @warning Запрещено создавать экземпляр напрямую (`new`, стек). Используйте
 * только `create()`.
 * @warning Запрещено удалять объект вручную (`delete`). Используйте только
 * `destroy()`.
 * @warning Нельзя вызывать методы класса напрямую — только через C API обёртки.
 *
 * @par Пример использования (через C API):
 * @code
 * void* game = SnakeGame::create();
 * if (!game) {
 *   // ошибка инициализации
 * }
 *
 * // Запуск игры
 * SnakeGame::handle_input(game, Start, false);
 *
 * // Основной цикл
 * while (!SnakeGame::isGameOver(game)) {
 *     SnakeGame::update(game);
 *     const GameInfo_t* info = SnakeGame::get_info(game);
 *     render(info);
 *     usleep(info->speed * 1000);
 * }
 *
 * SnakeGame::destroy(game);
 * @endcode
 */
class SnakeGame {
 public:
  static void* create() noexcept;
  static void destroy(void* game) noexcept;

  static void handle_input(void* game, UserAction_t action, bool hold) noexcept;
  static void update(void* game) noexcept;

  static const GameInfo_t* get_info(const void* game) noexcept;

  /**
   * @brief Запрещает копирование экземпляра игры
   *
   * Удаляет конструктор копирования, чтобы предотвратить создание копии объекта
   * SnakeGame. Это необходимо, поскольку:
   * - игра управляет выделенной динамической памятью (info_.field)
   * - экземпляр инкапсулирован за непрозрачным указателем (void*)
   * - копирование привело бы к двойному освобождению памяти (double free)
   * - жизненный цикл строго контролируется через static create/destroy
   *
   * @note Попытка скопировать объект (например, SnakeGame other = *game;)
   * вызовет ошибку компиляции.
   * @warning Не удаляйте эту строку — нарушение приведёт к неопределённому
   * поведению.
   */
  SnakeGame(const SnakeGame&) = delete;

  /**
   * @brief Запрещает присваивание экземпляра игры
   *
   * Удаляет оператор присваивания копированием, чтобы предотвратить побитовое
   * копирование одного экземпляра SnakeGame в другой. Это необходимо для:
   * - предотвращения двойного освобождения памяти (double free) при удалении
   * объектов
   * - защиты от неправильного управления ресурсами (например, info_.field)
   * - обеспечения уникальности экземпляра, управляемого через C API
   *
   * @note Использование оператора = (например, game1 = game2;) вызовет ошибку
   * компиляции.
   * @warning Не удаляйте эту строку — это нарушит инкапсуляцию и приведёт к UB.
   */
  SnakeGame& operator=(const SnakeGame&) = delete;

  /**
   * @brief Запрещает перемещение экземпляра игры
   *
   * Удаляет конструктор перемещения, чтобы предотвратить передачу владения
   * ресурсами экземпляра SnakeGame через move-семантику. Это необходимо, потому
   * что:
   * - жизненный цикл объекта строго контролируется через статические методы
   * create/destroy
   * - экземпляр инкапсулирован за непрозрачным указателем (void*)
   * - перемещение нарушило бы инварианты управления памятью и состоянием
   *
   * @note Попытка переместить объект (например, SnakeGame other =
   * std::move(*game);) вызовет ошибку компиляции.
   * @warning Не удаляйте эту строку — это может привести к неопределённому
   * поведению и нарушению работы C API.
   */
  SnakeGame(SnakeGame&&) = delete;

  /**
   * @brief Запрещает перемещающее присваивание экземпляра игры
   *
   * Удаляет оператор присваивания с перемещением, чтобы предотвратить передачу
   * ресурсов одного экземпляра SnakeGame другому через семантику перемещения.
   * Это необходимо, так как:
   * - объект управляет критическими ресурсами (динамическая память под поле,
   * файловые дескрипторы)
   * - его жизненный цикл полностью контролируется через C API (create/destroy)
   * - перемещение нарушило бы инкапсуляцию и привело к неопределённому
   * поведению
   *
   * @note Использование оператора = с std::move (например, game1 =
   * std::move(game2);) вызовет ошибку компиляции.
   * @warning Не удаляйте эту строку — это может привести к двойному
   * освобождению памяти или повреждению состояния игры.
   */
  SnakeGame& operator=(SnakeGame&&) = delete;

  /**
   * @brief Возвращает текущее состояние конечного автомата игры
   * @return Текущее значение из перечисления SnakeState
   */
  SnakeState getState() const noexcept { return from_fsm_state(fsm_.current); }

  /**
   * @brief Возвращает текущее направление движения змейки
   * @return Текущее значение из перечисления Direction
   */
  Direction getDirection() const noexcept { return direction_; }

  /**
   * @brief Возвращает текущую длину змейки
   * @return Длина змейки в количестве сегментов
   */
  int getLength() const noexcept { return static_cast<int>(body_.size()); }

  /**
   * @brief Проверяет, завершена ли игра
   * @return true, если игра завершена (состояние GAME_OVER), иначе false
   */
  bool isGameOver() const noexcept {
    return s21::from_fsm_state(fsm_.current) == SnakeState::GAME_OVER;
  }

  /**
   * @brief Проверяет, находится ли игра на паузе
   * @return true, если игра приостановлена, иначе false
   */
  bool isPaused() const noexcept {
    return s21::from_fsm_state(fsm_.current) == SnakeState::PAUSED;
  }

  #ifdef SNAKE_TEST_ACCESS
    /// Установить позицию еды для тестов. Не использовать в релизе.
    void set_food_for_testing(int x, int y);
  #endif

 private:
  SnakeGame() noexcept;
  ~SnakeGame() noexcept;

  void initialize_() noexcept;
  void initializeSnake_() noexcept;

  void ensureScoreDir_() noexcept;
  bool loadHighScore_() noexcept;
  bool saveHighScore_() const noexcept;

  SnakeEvent mapActionToEvent_(UserAction_t action) const noexcept;
  void processEvent_(SnakeEvent ev) noexcept;
  void move_() noexcept;
  bool checkCollision_(const SnakeSegment& head) const noexcept;
  void handleCollision_() noexcept;
  bool checkAppleEaten_(const SnakeSegment& head) const noexcept;
  void eatApple_() noexcept;
  void spawnApple_() noexcept;
  void updateOccupiedCells_() noexcept;
  void rebuildOccupiedCells_() noexcept;
  void updateFieldState_() noexcept;
  void updateScore_() noexcept;
  static void on_state_enter_(fsm_context_t ctx);

  // Данные состояния игры
  GameInfo_t info_;  ///< Основная структура с информацией для отрисовки
  std::deque<SnakeSegment>
      body_;  ///< Тело змейки, хранится в виде двусторонней очереди (голова —
              ///< первый элемент)
  std::unordered_set<int>
      occupied_cells_;  ///< Множество занятых ячеек поля (ключ = y * cols + x)
  Direction direction_ = Direction::RIGHT;  //< Текущее направление движения
  Direction next_direction_ =
      Direction::RIGHT;  ///< Следующее направление (для предотвращения
                         ///< разворотов на 180°)
  int apple_x_ = -1;  ///< X-координата текущего яблока
  int apple_y_ = -1;  ///< Y-координата текущего яблока
  fsm_t fsm_{};      ///< Конечный автомат
  bool game_over_handled_ = false;  ///< Флаг обработки завершения игры
  int game_over_timer_ = 0;         ///< Счетчик для таймера завершения игры
  static constexpr int GAME_OVER_DELAY_TICKS = 60;  ///< Задержка в тика
  static const fsm_transition_t transitions_[];
};

}  // namespace s21

/**
 * @page snake_fsm_diagram Диаграмма состояний игры "Змейка"
 *
 * Ниже представлена корректная диаграмма переходов конечного автомата (FSM)
 игры "Змейка",
 * соответствующая логике, реализованной в классе `SnakeGame` и таблице
 `transitions_`.
 * Диаграмма точно отражает поведение игры на основе событий `SnakeEvent` и
 состояний `SnakeState`.
 *
 * @note
 * - Все переходы соответствуют реальной реализации в методе `processEvent_()` и
 таблице `transitions_`.
 * - Состояния и события строго типизированы через `enum class`, что
 обеспечивает безопасность FSM.
 * - Диаграмма игнорирует внутренние действия (например, обновление поля, рост
 змейки), фокусируясь только на переходах.
 *
 * @dot
 digraph SnakeFSM {
     rankdir=TB;
     node [shape=doublecircle, style=filled, fillcolor=lightblue]; INIT;
     node [shape=circle, style=filled, fillcolor=lightgoldenrodyellow];

     // Состояния
     INIT      [label="INIT\n(Ожидание старта)", color=green];
     MOVE      [label="MOVE\n(Игра активна)", color=blue];
     PAUSED    [label="PAUSED\n(Пауза)", color=orange];
     GAME_OVER [label="GAME_OVER\n(Игра окончена)", color=red];

     // Переходы
     INIT -> MOVE [label="START", fontcolor=green];

     MOVE -> PAUSED [label="PAUSE_TOGGLE", fontcolor=orange];
     PAUSED -> MOVE [label="PAUSE_TOGGLE", fontcolor=orange];

     MOVE -> GAME_OVER [label="COLLISION / TERMINATE", fontcolor=red];
     GAME_OVER -> INIT [label="AUTO_RESET", fontcolor=green];

     // Обработка движения (не вызывает смену состояния)
     MOVE -> MOVE [label="MOVE_LEFT, MOVE_RIGHT, MOVE_UP, MOVE_DOWN",
 fontcolor=blue];

     // Принудительное завершение
     MOVE -> GAME_OVER [label="TERMINATE", fontcolor=red];

     // Стилизация
     INIT      [fillcolor=lightgreen];
     GAME_OVER [fillcolor=pink];
     PAUSED    [fillcolor=yellow];
     MOVE      [fillcolor=lightcyan];
 }
 @enddot
 *
 * @section fsm_logic Логика конечного автомата
 *
 * Игра "Змейка" использует FSM с четырьмя основными состояниями:
 *
 * - @b INIT: начальное состояние. Игра ожидает события `START` для
 инициализации змейки и перехода в `MOVE`.
 * - @b MOVE: активная игра. Происходит движение змейки, обработка поворотов и
 столкновений.
 *            События `MOVE_*` изменяют направление, но не состояние.
 * - @b PAUSED: игра приостановлена. Обновления игрового поля не происходят.
 *              Только `PAUSE_TOGGLE` возвращает в `MOVE`.
 * - @b GAME_OVER: игра завершена. Отображается результат.
 *                 Только `START` перезапускает игру (выполняется `reset()` и
 переход в `MOVE`).
 *
 * @section events События и их обработка
 *
 * - @b START: запускает новую игру. Обрабатывается только из состояний `INIT` и
 `GAME_OVER`.
 * - @b PAUSE_TOGGLE: переключает режим паузы. Доступно только в `MOVE` и
 `PAUSED`.
 * - @b MOVE_*: изменяют направление змейки. Только `MOVE` обрабатывает эти
 события.
 * - @b TERMINATE: принудительно завершает игру из любого активного состояния
 (аналог выхода).
 *
 * @note
 * - Состояние `MAX` и событие `MAX` — служебные, не участвуют в FSM.
 * - Диаграмма не показывает изменение `next_direction_` — это внутреннее
 поведение состояния `MOVE`.
 * - Проверка столкновений (`checkCollision_()`) вызывается при каждом `move_()`
 и при необходимости переводит игру в `GAME_OVER`.
 *
 * @see SnakeGame::processEvent_()
 * @see SnakeGame::transitions_
 * @see SnakeState
 * @see SnakeEvent
 */