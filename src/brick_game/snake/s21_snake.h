/**
 * @file s21_snake.h
 * @brief Публичный C API (фасад) для игры "Змейка", совместимый с C-кодом
 * (s21_bgame)
 *
 * Определяет C-совместимый интерфейс для интеграции игры "Змейка" в
 * универсальный игровой движок s21_bgame. Все функции объявлены с linkage
 * `extern "C"` для корректной линковки с C-кодом.
 *
 * @note Реализация разделена на три уровня:
 *       - s21_snake.h           — публичный C API (этот файл)
 *       - s21_snake.cpp         — тонкая C обёртка над C++ классом
 *       - s21_snake_internals.hpp — объявление внутренней логики игры на C++17
 *       - s21_snake_internals.cpp — полная реализация логики на C++17
 * (s21::SnakeGame)
 *
 * @note Интерфейс использует паттерн "непрозрачный указатель" (Opaque Pointer, 
 *       Pointer to Implementation) (void*):
 *       - Контекст игры создаётся через snake_create()
 *       - Управление — через snake_handle_input(), snake_update()
 *       - Данные — через snake_get_info()
 *       - Освобождение — через snake_destroy()
 *
 * @note Все функции помечены как noexcept (через реализацию) — исключения C++
 *       не пересекают границу C API, что предотвращает неопределённое
 * поведение.
 *
 * @note API предполагает однопоточное использование: все вызовы для одного
 *       экземпляра игры должны выполняться из одного потока.
 *
 * @author provemet
 * @version 1.0
 * @date 2025-12-26
 * @see s21_snake.cpp          — C API обёртка
 * @see s21_snake_internals.hpp — объявление внутренней логики игры
 * @see s21_snake_internals.cpp — реализация класса s21::SnakeGame
 * @see s21_bgame.h             — универсальный интерфейс игрового движка
 */

#ifndef S21_SNAKE_H
#define S21_SNAKE_H

#include "s21_bgame.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Создаёт новый экземпляр игры "Змейка"
 *
 * Выделяет динамическую память и инициализирует состояние игры в начальный
 * режим (INIT). Возвращает непрозрачный указатель на внутреннюю структуру игры.
 *
 * @return void* Указатель на экземпляр игры (непрозрачный контекст), или NULL
 *         при ошибке (например, нехватка памяти).
 *
 * @note Память, выделенная через snake_create(), должна быть освобождена
 *       с помощью snake_destroy(). Неиспользование destroy() приведёт к утечке.
 * @note Функция является рекомендуемо-атомарной: при успешном вызове объект
 *       гарантированно находится в корректном начальном состоянии (INIT).
 *
 * @warning Функция не является потокобезопасной. Все вызовы API для одного
 *          экземпляра игры должны выполняться из одного и того же потока.
 * @warning Не допускается вызов из обработчиков сигналов или прерываний.
 *          Это может привести к неопределённому поведению.
 *
 * @par Пример:
 * @code
 * void* game = snake_create();
 * if (!game) {
 *     fprintf(stderr, "Ошибка: не удалось создать игру 'Змейка'\n");
 *     return -1;
 * }
 * // Успешное создание — объект готов к использованию
 * @endcode
 */
void* snake_create(void);

/**
 * @brief Уничтожает экземпляр игры "Змейка" и освобождает связанные ресурсы
 *
 * Полностью освобождает всю память и системные ресурсы, связанные с экземпляром
 * игры. Функция безопасна для вызова с NULL-указателем — в этом случае она
 * ничего не делает. После выполнения объект становится недействительным, и
 * доступ к нему запрещён.
 *
 * @param game Указатель на экземпляр игры. Может быть NULL — функция игнорирует
 * такой вызов.
 *
 * @note Рекомендуется устанавливать указатель в NULL сразу после вызова:
 *       это предотвращает случайный повторный вызов или использование мёртвого
 * указателя (use-after-free).
 * @note Вызов функции не влияет на другие экземпляры игры и не нарушает их
 * состояние.
 * @note Повторный вызов с тем же указателем (после первого успешного destroy)
 * приводит к неопределённому поведению — избегайте этого.
 *
 * @warning Функция не является потокобезопасной. Не допускается одновременный
 * вызов с другими функциями API для одного и того же экземпляра игры.
 * @warning Не должна вызываться из обработчиков сигналов, прерываний или
 * асинхронного кода — возможны нарушения целостности памяти и аварийное
 * завершение.
 * @warning После вызова функции все ссылки на этот экземпляр становятся
 * недействительными.
 *
 * @par Пример:
 * @code
 * snake_destroy(game);  // Освобождение ресурсов
 * game = NULL;          // Гарантия защиты от повторного использования
 * @endcode
 */
void snake_destroy(void* game);

/**
 * @brief Обрабатывает пользовательский ввод в игре "Змейка"
 *
 * Преобразует действие пользователя в событие конечного автомата (FSM) и
 * инициирует соответствующие изменения состояния игры: запуск, паузу, поворот,
 * выход. Непосредственное движение змейки **не происходит** в этом вызове — оно
 * обрабатывается в функции `snake_update()` на следующем игровом тике.
 *
 * @param game Указатель на экземпляр игры. Если равен NULL, функция безопасно
 * завершается без эффекта.
 * @param action Действие пользователя (см. перечисление UserAction_t).
 * Поддерживаемые значения:
 *               - Start:      запуск новой игры (переход из состояний INIT или
 * GAME_OVER → MOVE)
 *               - Pause:      переключение режима паузы (если игра активна)
 *               - Left:       попытка поворота змейки влево (если разворот на
 * 180° не запрещён)
 *               - Right:      попытка поворота вправо (аналогично)
 *               - Up:         попытка движения вверх
 *               - Down:       попытка ускоренного спуска (если реализовано)
 *               - Action:     зарезервировано — не обрабатывается (для
 * совместимости с API)
 *               - Terminate:  немедленное завершение игры (переход в GAME_OVER)
 * @param hold   Флаг удержания клавиши:
 *               - true:  указывает на постоянное удержание (например, для
 * ускорения)
 *               - false: однократное нажатие
 *               Учитывается только для действий Left, Right, Up и Down.
 *
 * @note Функция безопасна для вызова с NULL в параметре `game` — никаких
 * действий не выполняет.
 * @note Поведение **не определено**, если передано значение `action`, не
 * входящее в `UserAction_t`. Передавайте только валидные, документированные
 * значения.
 * @note Вызовы из разных потоков **для одного экземпляра игры** приведут к
 * гонкам данных — соблюдайте однопоточность.
 *
 * @warning Функция не является потокобезопасной. Все вызовы, относящиеся к
 * одному экземпляру игры, должны происходить из одного и того же потока.
 * @warning Не допускается вызов из обработчиков сигналов, прерываний или других
 * асинхронных контекстов. Это может привести к повреждению состояния игры или
 * аварийному завершению.
 *
 * @par Пример:
 * @code
 * // Начать игру
 * snake_handle_input(game, Start, false);
 *
 * // Поворот влево (одно нажатие)
 * snake_handle_input(game, Left, false);
 *
 * // Движение вниз с удержанием (ускорение)
 * snake_handle_input(game, Down, true);
 *
 * // Поставить на паузу
 * snake_handle_input(game, Pause, false);
 *
 * // Завершить игру
 * snake_handle_input(game, Terminate, false);
 * @endcode
 */
void snake_handle_input(void* game, UserAction_t action, bool hold);

/**
 * @brief Обновляет состояние игры на один игровой тик
 *
 * Вызывается регулярно по таймеру. Выполняет полный шаг игровой логики:
 * - Перемещение змейки (если игра находится в состоянии MOVE)
 * - Проверку столкновений с границами поля и с собственным телом
 * - Проверку попадания головы змейки на яблоко и её рост при успехе
 * - Генерацию нового яблока на свободной ячейке
 * - Обновление счёта, уровня и скорости (с учётом прогресса)
 * - Управление переходами между состояниями конечного автомата (FSM)
 *
 * @param game Указатель на экземпляр игры. Если равен NULL, функция безопасно
 * завершается без эффекта.
 *
 * @note Рекомендуемая частота вызова: 5–20 раз в секунду — обеспечивает
 * плавность анимации.
 * @note Значение `info->speed`, возвращаемое через `snake_get_info()`,
 * указывает текущую задержку между тиками в миллисекундах. Контроллер должен
 * использовать это значение для точного управления таймингом.
 * @note Функция идемпотентна по отношению к `NULL`: многократные вызовы с `game
 * == NULL` безопасны.
 * @note Поведение не определено, если `game` указывает на повреждённый или уже
 * уничтоженный экземпляр.
 * @note Вызовы `snake_update()` в состоянии PAUSED или INIT не приводят к
 * движению змейки — логика активна только в состоянии MOVE.
 *
 * @warning Функция не является потокобезопасной. Все вызовы для одного
 * экземпляра игры должны выполняться из одного и того же потока.
 * @warning Запрещено вызывать из обработчиков сигналов, прерываний или
 * асинхронных колбэков — возможны повреждение памяти или аварийное завершение.
 * @warning Параллельный доступ из нескольких потоков приводит к гонкам данных и
 * нестабильности состояния.
 *
 * @par Пример:
 * @code
 * while (1) {
 *     const GameInfo_t* info = snake_get_info(game);
 *     if (!info || info->game_over) break;
 *
 *     snake_update(game);
 *
 *     info = snake_get_info(game);
 *     render_game(info);
 *
 *     // Контроллер использует info->speed как рекомендуемую задержку
 *     usleep(info->speed * 1000);  // speed в мс → в микросекунды
 * }
 * @endcode
 */
void snake_update(void* game);

/**
 * @brief Возвращает текущее состояние игры для отрисовки и отладки
 *
 * Получает указатель на константную структуру GameInfo_t, содержащую всю
 * необходимую информацию для отображения игры:
 * - field: двумерный массив [20][10], представляющий текущее состояние игрового
 * поля
 * - next:  матрица [4][4] — зарезервирована для совместимости, всегда NULL (не
 * используется)
 * - score: текущий счёт игрока (увеличивается при съедании яблока)
 * - high_score: рекордный счёт, сохранённый между сессиями
 * - level: текущий уровень сложности (автоматически растёт с прогрессом)
 * - speed: рекомендуемая задержка между вызовами snake_update() в
 * миллисекундах. Контроллер должен использовать это значение для управления
 * частотой тиков.
 * - pause: флаг паузы (1 — игра приостановлена, 0 — активна)
 * - game_over: флаг окончания игры (1 — игра завершена, 0 — продолжается)
 *
 * Формат данных в field:
 * - 0:       пустая ячейка
 * - 2:       голова змейки
 * - 1:       сегмент тела змейки
 * - 3:       яблоко (еда)
 *
 * @param game Указатель на экземпляр игры. Если равен NULL, функция возвращает
 * NULL.
 * @return Указатель на константную структуру GameInfo_t.
 *         NULL, если game == NULL, экземпляр не инициализирован или был
 * уничтожен.
 *
 * @note Возвращаемый указатель **действителен только до следующего вызова
 * snake_update() или snake_destroy()**. Сохранение указателя или доступ к нему
 * после этого приводит к неопределённому поведению.
 * @note Поля field и next указывают на внутренние данные игры — **запрещено
 * изменять их напрямую**.
 * @note Состояние поля (field) обновляется при каждом вызове snake_update(), а
 * не в реальном времени.
 * @note Для получения актуального состояния всегда вызывайте snake_get_info()
 * **после** snake_update().
 *
 * @warning Функция не является потокобезопасной. Все вызовы, относящиеся к
 * одному экземпляру игры, должны выполняться из одного и того же потока.
 * @warning Запрещено вызывать из обработчиков сигналов, прерываний или
 * асинхронных колбэков.
 * @warning Параллельный вызов с snake_update() или другими функциями API
 * приводит к гонкам данных.
 *
 * @par Пример:
 * @code
 * // Основной игровой цикл
 * while (1) {
 *     snake_update(game);  // Обновление логики
 *
 *     const GameInfo_t* info = snake_get_info(game);
 *     if (!info || info->game_over) break;
 *
 *     // Отладочный вывод
 *     printf("Счёт: %d | Рекорд: %d | Уровень: %d | Скорость: %d мс\n",
 *            info->score, info->high_score, info->level, info->speed);
 *     printf("Пауза: %s | Игра окончена: %s\n",
 *            info->pause ? "Да" : "Нет", info->game_over ? "Да" : "Нет");
 *
 *     // Отрисовка игрового поля
 *     for (int y = 0; y < 20; ++y) {
 *         for (int x = 0; x < 10; ++x) {
 *             if (info->field[y][x] == 3) {
 *                 printf("()");  // Яблоко
 *             } else if (info->field[y][x] == 2) {
 *                 printf("HH");  // Голова
 *             } else if (info->field[y][x] == 1) {
 *                 printf("[]");  // Тело
 *             } else {
 *                 printf("  ");  // Пустая ячейка
 *             }
 *         }
 *         printf("\n");
 *     }
 *
 *     usleep(info->speed * 1000);  // Управление таймингом
 * }
 * @endcode
 */
const GameInfo_t* snake_get_info(const void* game);

/**
 * @brief Возвращает интерфейс игры "Змейка" для регистрации в игровом движке
 * BrickGame
 *
 * Создаёт и возвращает заполненную структуру GameInterface_t, содержащую
 * указатели на функции управления игрой: создание, ввод, обновление, получение
 * состояния и уничтожение. Предназначена для интеграции с универсальным игровым
 * движком s21_bgame.
 *
 * @param id Идентификатор запрашиваемой игры (GameId_t).
 *           Поддерживается только значение `GAME_SNAKE`.
 *           Для любого другого значения функция возвращает обнулённую структуру
 * (все поля — NULL/0).
 *
 * @return GameInterface_t Заполненная структура интерфейса, если id ==
 * GAME_SNAKE; иначе — полностью нулевая структура.
 *
 * @note Функция **чистая (pure)** по семантике: результат зависит только от
 * значения id. При многократных вызовах с одинаковым id возвращает идентичный
 * результат.
 * @note Возвращаемая структура содержит только указатели на статические функции
 * — выделение или освобождение памяти не требуется.
 * @note Подходит для прямого использования или передачи в `bg_register_game()`.
 * @note Гарантируется, что все поля интерфейса (create, destroy, input, update,
 * get_info) установлены корректно при id == GAME_SNAKE.
 *
 * @warning Функция не является потокобезопасной. Параллельный вызов из
 * нескольких потоков без внешней синхронизации приводит к гонкам данных.
 * @warning Запрещено вызывать из обработчиков сигналов, прерываний или
 * асинхронных колбэков — возможны нарушения целостности состояния.
 *
 * @par Пример использования с s21_bgame:
 * @code
 * // Получение интерфейса игры "Змейка"
 * GameInterface_t snake_iface = snake_get_interface(GAME_SNAKE);
 * if (!snake_iface.create || !snake_iface.update || !snake_iface.get_info) {
 *     fprintf(stderr, "Ошибка: интерфейс игры 'Змейка' некорректен или не
 * поддерживается\n"); return -1;
 * }
 *
 * // Регистрация игры в движке
 * bg_register_game(snake_iface);
 *
 * // Создание экземпляра игры
 * void* game = snake_iface.create();
 * if (!game) {
 *     fprintf(stderr, "Ошибка: не удалось создать экземпляр игры 'Змейка'\n");
 *     return -1;
 * }
 *
 * // Запуск новой игры
 * snake_iface.input(game, Start, false);
 *
 * // Основной игровой цикл
 * while (1) {
 *     snake_iface.update(game);
 *
 *     const GameInfo_t* info = snake_iface.get_info(game);
 *     if (!info || info->game_over) break;
 *
 *     render_game(info);
 *
 *     // Управление таймингом: info->speed задаёт задержку в миллисекундах
 *     usleep(info->speed * 1000);
 * }
 *
 * // Освобождение ресурсов
 * snake_iface.destroy(game);
 * game = NULL;
 * @endcode
 */
GameInterface_t snake_get_interface(GameId_t id);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // S21_SNAKE_H