/**
 * @file s21_snake.h
 * @brief Публичный C API (фасад) для игры "Змейка", совместимый с C-кодом (s21_bgame)
 *
 * Данный заголовок определяет интерфейс, предназначенный для вызова из C-кода
 * (например, через s21_bgame). Все функции объявлены с linkage `extern "C"`
 * для обеспечения совместимости с C-линковкой.
 *
 * @note Реальная реализация на C++17 находится в:
 *       - s21_snake.cpp — C API обёртка
 *       - s21_snake_internals.cpp — логика игры (класс s21::SnakeGame)
 *
 * @author provemet
 * @version 1.0
 * @date 2025-12-26
 * @see s21_snake.cpp, s21_snake_internals.hpp, s21_bgame.h
 */

#ifndef S21_SNAKE_H
#define S21_SNAKE_H

#include "s21_bgame.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Создаёт новый экземпляр игры "Змейка"
 *
 * Выделяет динамическую память и инициализирует состояние игры в начальный режим (INIT).
 * Возвращает непрозрачный указатель на внутреннюю структуру игры.
 *
 * @return void* Указатель на экземпляр игры (непрозрачный контекст), или NULL при ошибке
 *
 * @note Память, выделенная через snake_create(), должна быть освобождена вызовом snake_destroy().
 * @warning Функция не является потокобезопасной. Все вызовы API для одного экземпляра игры
 *          должны выполняться из одного и того же потока.
 * @warning Не допускается вызов из обработчиков сигналов или прерываний.
 *
 * @par Пример:
 * @code
 * void* game = snake_create();
 * if (!game) {
 *     fprintf(stderr, "Ошибка: не удалось создать игру 'Змейка'\n");
 *     return -1;
 * }
 * @endcode
 */
void* snake_create(void);

/**
 * @brief Уничтожает экземпляр игры "Змейка" и освобождает связанные ресурсы
 *
 * Полностью освобождает память, занятую экземпляром игры, и завершает её состояние.
 * Корректно обрабатывает значение NULL — безопасен для повторного или нулевого вызова.
 *
 * @param game Указатель на экземпляр игры (может быть NULL)
 *
 * @note Рекомендуется после вызова устанавливать указатель в NULL, чтобы избежать use-after-free.
 * @warning Функция не является потокобезопасной. Не допускается одновременный вызов
 *          с другими функциями API для одного и того же экземпляра игры.
 * @warning Не должна вызываться из обработчиков сигналов, прерываний или асинхронного контекста.
 *
 * @par Пример:
 * @code
 * snake_destroy(game);
 * game = NULL; // Предотвращение повторного использования
 * @endcode
 */
void snake_destroy(void* game);

/**
 * @brief Обрабатывает пользовательский ввод в игре "Змейка"
 *
 * Преобразует действие пользователя в событие конечного автомата (FSM) и обновляет
 * состояние игры (например, поворот, паузу, запуск). Движение змейки происходит
 * в функции snake_update() — не в этом вызове.
 *
 * @param game Указатель на экземпляр игры (может быть NULL — безопасно игнорируется)
 * @param action Действие пользователя (см. UserAction_t)
 *               Поддерживаемые действия:
 *               - Start: начать новую игру (переход из INIT → SPAWN)
 *               - Pause: поставить на паузу или возобновить
 *               - Left: попытка поворота влево (если возможно)
 *               - Right: попытка поворота вправо (если возможно)
 *               - Down: попытка движения вниз (если возможно)
 *               - Action: ускорение движения
 *               - Terminate: завершить игру немедленно
 *               - Up: попытка движения вверх (если возможно)
 * @param hold Флаг удержания клавиши:
 *             - true: клавиша удерживается (например, постоянное ускорение)
 *             - false: однократное нажатие
 *             Учитывается только для действий Down и Action.
 *
 * @note Функция безопасна при передаче NULL в параметре game — ничего не делает.
 * @note Поведение не определено, если передан невалидный (неизвестный) UserAction_t.
 * @warning Функция не является потокобезопасной. Все вызовы для одного экземпляра игры
 *          должны происходить из одного потока.
 * @warning Не должна вызываться из асинхронных контекстов (обработчики сигналов, прерывания).
 *
 * @par Пример:
 * @code
 * // Поворот влево (однократное нажатие)
 * snake_handle_input(game, Left, false);
 *
 * // Ускорение (удержание клавиши вниз)
 * snake_handle_input(game, Down, true);
 *
 * // Запуск новой игры
 * snake_handle_input(game, Start, false);
 *
 * // Выход из игры
 * snake_handle_input(game, Terminate, false);
 * @endcode
 */
void snake_handle_input(void* game, UserAction_t action, bool hold);

/**
 * @brief Обновляет состояние игры на один игровой тик
 *
 * Вызывается регулярно по таймеру. Выполняет основной цикл логики игры:
 * - Перемещение змейки (если прошёл достаточный интервал времени, согласно скорости)
 * - Проверку столкновений (со стенами, самой собой)
 * - Проверку съедения яблока и генерацию нового
 * - Обновление счёта, уровня и скорости при необходимости
 * - Управление переходами между состояниями конечного автомата (FSM)
 *
 * @param game Указатель на экземпляр игры. Если равен NULL, функция безопасно игнорируется.
 *
 * @note Рекомендуемая частота вызова: 5–20 раз в секунду (~50–200 мс), в зависимости от уровня.
 * @note Допускается многократный и частый вызов — функция корректно обрабатывает отсутствие игрового времени.
 * @note Поведение не определено, если game указывает на невалидный или повреждённый экземпляр.
 *
 * @warning Функция не является потокобезопасной. Все вызовы для одного экземпляра игры
 *          должны выполняться из одного и того же потока.
 * @warning Не допускается вызов из обработчиков прерываний, сигналов или других асинхронных контекстов.
 * @warning Параллельный доступ к одному экземпляру игры из разных потоков приведёт к гонкам данных и нестабильности.
 *
 * @par Пример:
 * @code
 * while (game_running) {
 *     snake_update(game);                    // Обновить логику
 *     const GameInfo_t* info = snake_get_info(game); // Получить состояние
 *     render_game(info);                     // Отрисовать
 *     usleep(100000);                        // Задержка ~100 мс (10 тиков/сек)
 * }
 * @endcode
 */
void snake_update(void* game);

/**
 * @brief Возвращает текущее состояние игры для отрисовки и отладки
 *
 * Получает указатель на константную структуру GameInfo_t, содержащую всю
 * необходимую информацию для отображения игры:
 * - field: двумерный массив [20][10], представляющий игровое поле
 * - next:  матрица [4][4] — зарезервирована, не используется (всегда NULL)
 * - score: текущий счёт игрока
 * - high_score: рекордный счёт (сохраняется между играми)
 * - level: текущий уровень сложности (обычно от 1 до 10)
 * - speed: текущая скорость игры в миллисекундах (интервал до следующего тика)
 * - pause: флаг паузы (1 — игра приостановлена, 0 — активна)
 * - game_over: флаг окончания игры (1 — игра завершена, 0 — продолжается)
 *
 * Формат данных в field:
 * - 0:   пустая ячейка
 * - 1–200: сегменты змейки (1 — голова, 2, 3, ... — тело, значения >1 не используются визуально)
 * - 255: яблоко (еда)
 *
 * @param game Указатель на экземпляр игры. Если равен NULL, функция возвращает NULL.
 * @return Указатель на константную структуру GameInfo_t.
 *         NULL, если game == NULL, игра не инициализирована или находится в нестабильном состоянии.
 *
 * @note Возвращаемый указатель остаётся валидным **только до следующего вызова snake_update()**
 *       или snake_destroy(). После этого использовать указатель нельзя — поведение не определено.
 * @note Поля field и next указывают на внутренние данные игры — **не изменяйте их напрямую**.
 * @note Функция потоконебезопасна: не вызывайте её параллельно с snake_update() или другими функциями API.
 *
 * @warning Не является потокобезопасной. Все вызовы для одного экземпляра игры
 *          должны выполняться из одного потока.
 * @warning Не допускается вызов из обработчиков сигналов, прерываний или асинхронного кода.
 * @warning Доступ к данным после вызова snake_update() может привести к гонкам данных или разыменованию мусора.
 *
 * @par Пример:
 * @code
 * const GameInfo_t* info = snake_get_info(game);
 * if (info) {
 *     printf("Счёт: %d\n", info->score);
 *     printf("Рекорд: %d\n", info->high_score);
 *     printf("Уровень: %d\n", info->level);
 *     printf("Скорость: %d мс\n", info->speed);
 *     printf("Пауза: %s\n", info->pause ? "Да" : "Нет");
 *     printf("Игра окончена: %s\n", info->game_over ? "Да" : "Нет");
 *
 *     // Отрисовка игрового поля
 *     for (int y = 0; y < 20; ++y) {
 *         for (int x = 0; x < 10; ++x) {
 *             if (info->field[y][x] == 255) {
 *                 printf("()");  // Яблоко
 *             } else if (info->field[y][x] > 0) {
 *                 printf("[]");   // Сегмент змейки
 *             } else {
 *                 printf(" ");   // Пустая ячейка
 *             }
 *         }
 *         printf("\n");
 *     }
 * }
 * @endcode
 */
const GameInfo_t* snake_get_info(const void* game);

/**
 * @brief Возвращает интерфейс игры "Змейка" для регистрации в игровом движке BrickGame
 *
 * Создаёт и возвращает заполненную структуру GameInterface_t, содержащую
 * указатели на функции управления игрой (создание, ввод, обновление и т.д.).
 * Предназначена для интеграции с универсальным движком s21_bgame.
 *
 * @param id Идентификатор запрашиваемой игры (GameId_t)
 *           Поддерживаемое значение: GAME_SNAKE
 *           Любое другое значение игнорируется — возвращается обнулённая структура.
 * @return GameInterface_t Заполненная структура интерфейса, если id == GAME_SNAKE;
 *                         иначе — обнулённая структура (все поля = 0 или NULL)
 *
 * @note Функция может быть вызвана многократно — всегда возвращает одинаковый результат
 *       для одного и того же значения id.
 * @note Результат не требует освобождения памяти — все функции статические.
 * @note Подходит для передачи в bg_register_game() или прямого использования.
 *
 * @warning Функция не является потокобезопасной. Не вызывайте её параллельно
 *          из нескольких потоков без внешней синхронизации.
 * @warning Не допускается вызов из обработчиков сигналов, прерываний или асинхронного кода.
 *
 * @par Пример использования с s21_bgame:
 * @code
 * // Получить интерфейс для игры "Змейка"
 * GameInterface_t snake_iface = snake_get_interface(GAME_SNAKE);
 * if (!snake_iface.create || !snake_iface.update) {
 *     fprintf(stderr, "Ошибка: не удалось получить интерфейс игры 'Змейка'\n");
 *     return -1;
 * }
 *
 * // Зарегистрировать игру в движке
 * bg_register_game(snake_iface);
 *
 * // Создать экземпляр игры
 * void* game = snake_iface.create();
 * if (!game) {
 *     fprintf(stderr, "Ошибка: не удалось создать экземпляр игры\n");
 *     return -1;
 * }
 *
 * // Начать игру
 * snake_iface.input(game, Start, false);
 *
 * // Основной цикл обновления
 * while (!snake_get_info(game)->game_over) {
 *     snake_iface.update(game);
 *     const GameInfo_t* info = snake_get_info(game);
 *     render_game(info);
 *     usleep(100000); // ~10 тиков в секунду
 * }
 *
 * // Освободить ресурсы
 * snake_iface.destroy(game);
 * @endcode
 */
GameInterface_t snake_get_interface(GameId_t id);

#ifdef __cplusplus
} //extern "C"
#endif

#endif  // S21_SNAKE_H