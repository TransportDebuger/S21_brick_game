/**
 * @file s21_bgame.h
 * @brief Общий интерфейс игрового фреймворка для "кирпичных" игр (Tetris, Snake)
 *
 * Определяет унифицированный API для регистрации, переключения и управления играми
 * через полиморфный интерфейс GameInterface_t. Предоставляет глобальные функции
 * для обработки ввода, получения состояния и жизненного цикла игр.
 *
 * Реализует шаблон "виртуальные функции" в C, позволяет динамически переключаться
 * между играми без привязки к их внутренней реализации.
 *
 * @author provemet
 * @date 2025
 * @version 1.0
 *
 * @see s21_bgame.c
 * @note Потоконебезопасность не гарантируется. Используйте в однопоточном режиме.
 * @warning Прямое изменение полей GameInfo_t вызовет неопределённое поведение.
 */
#ifndef S21_BGAME_H_
#define S21_BGAME_H_

#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @def BGAME_FIELD_WIDTH
 * @brief Ширина игрового поля по умолчанию (в ячейках).
 *
 * Определяет горизонтальный размер игрового поля — количество столбцов,
 * используемое по умолчанию в библиотеке s21_bgame. Применяется во всех
 * играх, основанных на этой библиотеке (например, Snake, Tetris), для
 * обеспечения согласованности игрового пространства.
 *
 * @details
 *   - Используется при создании и индексации двумерного массива `field`.
 *   - Стандартное значение: 10 ячеек.
 *   - Применяется в:
 *     - проверках на выход за границы поля;
 *     - генерации игровых объектов (фигуры, еда);
 *     - расчёте позиций и столкновений.
 *
 * @note
 *   - Значение должно быть положительным целым числом.
 *   - Изменение макроса влияет на все игры в библиотеке —
 *     требует полной проверки корректности логики и отображения.
 *
 * @see BGAME_FIELD_HEIGHT — константа, определяющая высоту игрового поля.
 */
#define BGAME_FIELD_WIDTH 10

/**
 * @def BGAME_FIELD_HEIGHT
 * @brief Высота игрового поля по умолчанию.
 *
 * Определяет количество строк (вертикальный размер) игрового поля,
 * используемого в библиотеке s21_bgame. Данная константа применяется
 * во всех играх, основанных на этой библиотеке (например, Snake, Tetris),
 * для унификации размеров игрового пространства.
 *
 * @details
 * - Значение используется при выделении и индексации двумерного массива `field`.
 * - Стандартная высота игрового поля — 20 ячеек.
 * - Применяется в логике движения фигур, проверке столкновений с границами,
 *   генерации новых элементов (например, деталей тетриса или еды для змейки).
 *
 * @note Рекомендуется использовать только положительные целочисленные значения.
 *       Изменение этого макроса может повлиять на баланс и логику всех игр,
 *       поэтому требует тщательного тестирования.
 *
 * @see BGAME_FIELD_WIDTH — соответствующая ширина поля.
 */
#define BGAME_FIELD_HEIGHT 20

/**
 * @brief Типы пользовательских действий в игровом фреймворке
 *
 * Перечисление определяет все возможные команды, которые могут быть отправлены
 * в игру со стороны пользователя через интерфейс ввода (клавиатура, сенсор,
 * геймпад и т.п.). Используется как унифицированный способ передачи ввода в
 * любую игру, зарегистрированную в системе.
 *
 * @note Значения перечисления начинаются с 0 и автоматически инкрементируются.
 *       Используется в функции input() интерфейса GameInterface_t и в функции
 *       userInput() API регламентированного заданием проекта.
 */
typedef enum {
  Start = 0,  ///< Запуск или перезапуск игры
  Pause,      ///< Переключение состояния паузы
  Terminate,  ///< Принудительное завершение игры
  Left,       ///< Движение или смещение влево
  Right,      ///< Движение или смещение вправо
  Up,  ///< Движение или смещение вверх (опционально, зависит от игры)
  Down,  ///< Движение или смещение вниз (например, ускоренное падение)
  Action  ///< Выполнение специального действия (например, поворот фигуры в
          ///< Tetris)
} UserAction_t;

/**
 * @brief Идентификаторы поддерживаемых игр в фреймворке
 *
 * Перечисление задаёт уникальные константы для каждой игры, которая может быть
 * зарегистрирована и запущена в рамках игрового движка. Используется для
 * идентификации и переключения между различными играми.
 *
 * @note При добавлении новой игры в систему, необходимо добавить
 * соответствующий элемент в это перечисление.
 */
typedef enum {
  GAME_UNDEFINED = 0, ///< Неопределенная игра (служебное значение)
  GAME_TETRIS = 1,  ///< Игра "Тетрис"
  GAME_SNAKE = 2    ///< Игра "Змейка"
} GameId_t;

/* ========================= Модель игры ================================= */

/**
 * @brief Структура, содержащая публичное состояние игры
 *
 * Эта структура используется для передачи текущего состояния игровой логики
 * во внешние компоненты, такие как графический интерфейс, система отладки или
 * тесты. Все поля предназначены только для чтения — изменение значений не
 * должно влиять на внутреннее состояние игры.
 *
 * @warning Указатели field и next ссылаются на внутренние данные экземпляра
 * игры. Память, на которую они указывают, управляется самой игрой. Вызывающий
 * код не должен освобождать эту память вручную. Валидность указателей
 * сохраняется только до следующего вызова метода update() или destroy()
 * соответствующей игры.
 *
 * @note Некоторые поля (например, next, speed, level) в основном актуальны
 *       для Tetris, но включены в общую структуру для унификации API.
 *       Для других игр (например, Snake) они могут быть не задействованы.
 *
 * @see GameInterface_t, updateCurrentState()
 */
typedef struct {
  int **field;  ///< Двумерный массив, представляющий игровое поле (размер
                ///< определяется игрой)
  int **next;  ///< Двумерный массив 4x4 с превью следующей фигуры (используется
               ///< в Tetris)
  int score;   ///< Текущий счёт игрока
  int high_score;  ///< Максимальный достигнутый счёт (рекорд)
  int level;  ///< Текущий уровень сложности
  int speed;  ///< Скорость игры (например, интервал таймера в миллисекундах)
  int pause;  ///< Флаг паузы: 0 — игра активна, 1 — игра приостановлена
} GameInfo_t;

/**
 * @brief Интерфейс игры — виртуальная таблица функций для полиморфной работы с
 * играми
 *
 * Данная структура определяет единый API для всех игр, поддерживаемых
 * фреймворком. Позволяет управлять разными играми (Tetris, Snake и др.) через
 * общий интерфейс без привязки к их внутренней реализации. Реализует паттерн
 * "виртуальные функции" в C.
 *
 * Каждая игра предоставляет свою реализацию этого интерфейса через
 * функцию-фабрику (например, tetris_get_interface()), которая заполняет поля
 * структуры указателями на конкретные функции.
 *
 * @note Все указатели на функции должны быть валидными при регистрации игры.
 *       Игра с нулевыми (NULL) методами create/destroy может привести к сбоям.
 *
 * @see bg_register_game(), bg_switch_game(), GameId_t, GameInfo_t
 */
typedef struct {
  GameId_t id;  ///< Уникальный идентификатор игры (например, GAME_TETRIS)

  /**
   * @brief Создаёт и инициализирует новый экземпляр игры
   * @return Указатель на вновь созданный экземпляр игры, или NULL при ошибке
   *
   * @note Выделенная память должна быть корректно освобождена через destroy().
   */
  void *(*create)(void);

  /**
   * @brief Уничтожает экземпляр игры и освобождает всю связанную память
   * @param game Указатель на экземпляр игры (может быть NULL)
   *
   * @note Должна корректно обрабатывать NULL-указатель (no-op).
   */
  void (*destroy)(void *game);

  /**
   * @brief Обрабатывает пользовательский ввод
   * @param game Указатель на экземпляр игры
   * @param action Тип действия пользователя (см. UserAction_t)
   * @param hold Признак удержания клавиши (например, для hard-drop при нажатии
   * вниз)
   *
   * @note Должна быть безопасна для вызова в любых состояниях игры.
   */
  void (*input)(void *game, UserAction_t action, bool hold);

  /**
   * @brief Выполняет один игровой тик (обновление логики)
   * @param game Указатель на экземпляр игры
   *
   * @note Метод вызывается регулярно с фиксированной частотой (например, 10 раз
   * в секунду). Должен обновить состояние игры: перемещение фигур, проверку
   * коллизий и т.д.
   */
  void (*update)(void *game);

  /**
   * @brief Возвращает текущее состояние игры
   * @param game Указатель на экземпляр игры
   * @return Указатель на константную структуру GameInfo_t с текущим состоянием
   *
   * @note Указатель остаётся валидным до следующего вызова update() или
   * destroy(). Не освобождайте память, на которую он указывает.
   */
  const GameInfo_t *(*get_info)(const void *game);
} GameInterface_t;

/**
 * @brief Регистрирует игру в глобальном реестре фреймворка
 *
 * Добавляет интерфейс игры в систему, позволяя получать к нему доступ по её
 * идентификатору (GameId_t). Повторная регистрация игры с уже существующим ID
 * игнорируется без перезаписи.
 *
 * @param[in] iface Структура GameInterface_t, содержащая функции и ID игры
 *
 * @note Функция потоконебезопасна — должна вызываться в однопоточном контексте,
 *       например, при инициализации приложения.
 *
 * @warning Не проверяет корректность указателей в iface (create, destroy и
 * др.). Передача невалидных функций может привести к сбою при последующем
 * использовании.
 *
 * Пример использования:
 * @code
 * GameInterface_t tetris_interface = tetris_get_interface(GAME_TETRIS);
 * bg_register_game(tetris_interface);
 * @endcode
 *
 * @see bg_get_game(), GameInterface_t, GameId_t
 */
void bg_register_game(GameInterface_t iface);

/**
 * @brief Получает зарегистрированный интерфейс игры по её идентификатору
 *
 * Ищет в реестре игры интерфейс с указанным ID и возвращает указатель на него.
 * Используется для получения доступа к функциям игры (создание, обновление и
 * т.д.) перед её запуском или переключением.
 *
 * @param[in] id Уникальный идентификатор игры (например, GAME_TETRIS,
 * GAME_SNAKE)
 * @return Указатель на константный интерфейс игры, или NULL, если игра не
 * зарегистрирована
 *
 * @note Возвращаемый указатель остаётся валидным до конца работы программы,
 *       так как интерфейсы не удаляются из реестра.
 *
 * @warning Не создаёт экземпляр игры — только возвращает её интерфейс.
 *          Для запуска игры используйте bg_switch_game() или вызовите create()
 * вручную.
 *
 * Пример использования:
 * @code
 * const GameInterface_t *iface = bg_get_game(GAME_TETRIS);
 * if (iface) {
 *     void *game = iface->create();
 *     // ...
 * }
 * @endcode
 *
 * @see bg_register_game(), bg_switch_game(), GameInterface_t
 */
const GameInterface_t *bg_get_game(GameId_t id);

/**
 * @brief Переключается на игру с указанным идентификатором
 *
 * Уничтожает текущий активный экземпляр игры (если он существует) и создаёт
 * новый экземпляр игры, зарегистрированной под заданным ID. Если целевая игра
 * уже активна, переключение не выполняется — сохраняется текущее состояние.
 *
 * @param[in] id Идентификатор игры, на которую необходимо переключиться
 * @return true, если переключение успешно или игра уже была активна;
 *         false, если игра не зарегистрирована или не удалось создать её
 * экземпляр
 *
 * @note Функция проверяет, что методы create и destroy интерфейса игры не равны
 * NULL.
 * @note Функция гарантирует согласованное состояние: поля g_current.iface и
 *       g_current.instance всегда соответствуют одной и той же игре или равны
 * NULL. После неудачного вызова create() интерфейс также сбрасывается.
 *
 * @warning Не является потокобезопасной. Должна вызываться из основного потока.
 *
 * Пример использования:
 * @code
 * if (bg_switch_game(GAME_TETRIS)) {
 *     // Игра успешно переключена или уже была активна
 * } else {
 *     // Ошибка: игра не зарегистрирована, повреждена или не удалось создать
 * экземпляр
 * }
 * @endcode
 *
 * @see bg_register_game(), bg_get_current_game(), bg_get_current_instance(),
 * GameInterface_t
 */
bool bg_switch_game(GameId_t id);

/**
 * @brief Получает интерфейс текущей активной игры
 *
 * Возвращает указатель на интерфейс (GameInterface_t) игры, которая в данный
 * момент является активной в системе. Используется для доступа к методам игры
 * (create, destroy, input и т.д.) без прямого управления её экземпляром.
 *
 * @return Указатель на константный интерфейс текущей игры, или NULL, если
 * активной игры нет
 *
 * @note Возвращаемый указатель действителен, пока игра остаётся активной.
 *       Не требует ручного освобождения памяти.
 *
 * @warning Не создаёт и не инициализирует игру. Активная игра должна быть
 * установлена с помощью bg_switch_game() или аналогичной функции.
 *
 * Пример использования:
 * @code
 * const GameInterface_t *current = bg_get_current_game();
 * if (current) {
 *     printf("Активная игра: %d\n", current->id);
 * }
 * @endcode
 *
 * @see bg_switch_game(), bg_get_current_instance(), bg_get_game()
 */
const GameInterface_t *bg_get_current_game(void);

/**
 * @brief Получает указатель на экземпляр текущей активной игры
 *
 * Возвращает указатель на внутреннее состояние (приватные данные) текущей игры,
 * созданное через метод create() её интерфейса. Этот указатель необходим
 * для непосредственной передачи в функции input(), update() и get_info().
 *
 * @return Указатель на экземпляр активной игры, или NULL, если активной игры
 * нет
 *
 * @note Владение памятью остаётся за фреймворком. Освобождение памяти
 *       должно выполняться только через destroy() интерфейса при переключении
 *       или завершении работы.
 *
 * @warning Не создает новый экземпляр игры — возвращает уже существующий.
 *          Поведение не определено, если игра была уничтожена вручную.
 *
 * Пример использования:
 * @code
 * void *game = bg_get_current_instance();
 * if (game) {
 *     const GameInfo_t *info = bg_get_current_game()->get_info(game);
 *     // Работа с состоянием игры
 * }
 * @endcode
 *
 * @see bg_switch_game(), bg_get_current_game(), GameInterface_t
 */
void *bg_get_current_instance(void);

/**
 * @brief Обрабатывает пользовательский ввод для текущей активной игры
 *
 * Передаёт действие пользователя в активную игру через её интерфейс input().
 * Функция является обёрткой, упрощающей взаимодействие с текущей игрой
 * без необходимости явно управлять указателями на её экземпляр.
 *
 * @param[in] action Тип действия пользователя (Start, Pause, Left, Right и
 * т.д.)
 * @param[in] hold   Признак удержания клавиши (true — клавиша удерживается,
 * например для hard-drop)
 *
 * @note Если активная игра не установлена (например, не вызывался
 * bg_switch_game), функция ничего не делает — безопасна для вызова в любом
 * состоянии.
 *
 * @warning Не является потокобезопасной. Должна вызываться из основного
 * игрового потока.
 *
 * Пример использования:
 * @code
 * userInput(Left, false);   // Движение влево
 * userInput(Down, true);    // Ускоренное падение (удержание)
 * userInput(Action, false); // Поворот фигуры
 * @endcode
 *
 * @see bg_switch_game(), updateCurrentState(), GameInterface_t::input
 */
void userInput(UserAction_t action, bool hold);

/**
 * @brief Выполняет игровой тик и возвращает текущее состояние активной игры
 *
 * Обновляет логику активной игры, вызывая её метод update(), а затем получает
 * актуальное состояние игры через get_info(). Возвращённая структура содержит
 * все необходимые данные для отрисовки: поле, счёт, уровень, паузу и т.д.
 *
 * @return Копия структуры GameInfo_t с текущим состоянием игры.
 *         Если активной игры нет, возвращается обнуленная структура.
 *
 * @note Поля field и next содержат указатели на внутренние данные игры.
 *       Эти указатели остаются валидными только до следующего вызова
 *       updateCurrentState() или уничтожения игры. Не сохраняйте их надолго.
 *
 * @warning Функция не является потокобезопасной. Должна вызываться
 *          из основного игрового потока.
 *
 * Пример использования:
 * @code
 * GameInfo_t info = updateCurrentState();
 * if (info.field) {
 *     // Отрисовка игрового поля
 *     renderField(info.field);
 * }
 * @endcode
 *
 * @see userInput(), bg_switch_game(), GameInfo_t, GameInterface_t::update
 */
GameInfo_t updateCurrentState(void);

#ifdef TEST_ENV
void bg_reset_current_for_testing(void);
void bg_reset_registry_for_testing(void);
#endif

#ifdef __cplusplus
}
#endif

#endif  // S21_BGAME_H_