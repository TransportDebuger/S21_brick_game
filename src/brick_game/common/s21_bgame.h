/**
 * @file s21_bgame.h
 * @brief Публичный интерфейс (контракт) для библиотек игр серии BrickGame
 *
 * Это основной API, который должны реализовать все игры (Tetris, Snake,
 * Racing, Frogger и т.д.). Интерфейс не зависит от языка программирования
 * и предназначен для использования из C, C++, Python, Java, Go, JavaScript
 * и других языков через соответствующие биндинги.
 *
 * API состоит из двух главных функций:
 * - userInput() - обработка пользовательского ввода с консоли
 * - updateCurrentState() - получение текущего состояния игры для отрисовки
 *
 * API работает с двумя основными структурами данных:
 * - UserAction_t - перечисление возможных действий пользователя
 * - GameInfo_t - структура, представляющая полное состояние игры
 *
 * @author provemet
 * @version 1.0
 * @date 2025-12-16
 */

#ifndef BRICKGAME_H
#define BRICKGAME_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>

/** @brief Ширина игрового поля в пикселях */
#define FIELD_WIDTH 10

/** @brief Высота игрового поля в пикселях */
#define FIELD_HEIGHT 20

/** @brief Размер превью следующей фигуры */
#define PREVIEW_SIZE 4

/** @brief Минимальный уровень */
#define MIN_LEVEL 1

/** @brief Максимальный уровень (рекомендуемый) */
#define MAX_LEVEL 10

/**
 * @enum UserAction_t
 * @brief Действия пользователя, полученные с физической консоли
 *
 * Перечисление всех возможных действий пользователя, которые могут быть
 * получены с 8 физических кнопок консоли:
 * - "Старт"
 * - "Пауза"
 * - "Выход"
 * - 4 стрелки направления (Вверх, Вниз, Влево, Вправо)
 * - "Действие" (зависит от контекста, например, вращение в Tetris)
 *
 * Числовые значения (0-7) намеренно выбраны и соответствуют индексам кнопок
 * на физической консоли для консистентности на всех платформах.
 * 
 * @note В разных играх может отсутствовать то или иное действие.
 */
typedef enum {
    Start = 0,      ///< "Старт" - начать игру
    Pause = 1,      ///< "Пауза" - пауза/возобновление
    Terminate = 2,  ///< "Выход" - завершить игру
    Left = 3,       ///< Стрелка влево - движение влево
    Right = 4,      ///< Стрелка вправо - движение вправо
    Up = 5,         ///< Стрелка вверх - движение вверх
    Down = 6,       ///< Стрелка вниз - движение вниз
    Action = 7      ///< Кнопка "Действие" - зависит от игры (вращение в Tetris)
} UserAction_t;

/**
 * @struct GameInfo_t
 * @brief Полная информация о состоянии игры в текущий момент
 *
 * Эта структура представляет полное состояние любой игры в любой момент.
 * Возвращается функцией updateCurrentState() и должна использоваться
 * для отрисовки GUI (вывод игрового поля, счёта, уровня и т.д.).
 *
 * Структура разработана для того, чтобы быть:
 * - Независимой от языка (может быть отображена на классы Python, Java и т.д.)
 * - Достаточно простой для привязки к другим языкам
 * - Достаточно полной для отрисовки полного состояния игры без доп. запросов
 *
 * @note Указатели field и next должны быть инициализированы реализацией игры
 *       перед использованием. Слой GUI не должен напрямую модифицировать
 *       эти указатели или их содержимое.
 *
 * @note Все числовые значения (score, level, speed) - целые неотрицательные.
 */
typedef struct {
    /**
     * @brief Состояние игрового поля
     *
     * 2D массив размером 20 (высота) x 10 (ширина).
     * Каждый элемент может быть:
     * - 0: пустая ячейка (нет блока)
     * - 1: заполненная ячейка
     *
     * Индексация: field[строка][столбец] где:
     * - строка диапазон 0 (верхняя) до 19 (нижняя)
     * - столбец диапазон 0 (левая) до 9 (правая)
     *
     * Пример использования в C:
     * @code
     * GameInfo_t state = updateCurrentState();
     * int cell_value = state.field[10][5];  // Строка 10, столбец 5
     * @endcode
     *
     * Не должен быть NULL после вызова updateCurrentState().
     */
    int **field;

    /**
     * @brief Превью следующей фигуры
     *
     * 2D массив размером 4 (высота) x 4 (ширина).
     * Показывает превью следующей фигуры/предмета, который появится в игре.
     * Каждый элемент может быть:
     * - 0: пустая ячейка
     * - 1: часть следующей фигуры
     *
     * Использование в разных играх:
     * - Tetris: показывает следующий тетромино
     * - Другие: значение зависит от игры
     *
     * Индексация: next[строка][столбец] где:
     * - строка диапазон 0 до 3
     * - столбец диапазон 0 до 3
     *
     * Пример использования в C:
     * @code
     * GameInfo_t state = updateCurrentState();
     * for (int i = 0; i < 4; i++) {
     *     for (int j = 0; j < 4; j++) {
     *         if (state.next[i][j] == 1) {
     *             render_preview_cell(i, j);
     *         }
     *     }
     * }
     * @endcode
     *
     * Не должен быть NULL после вызова updateCurrentState().
     */
    int **next;

    /**
     * @brief Текущий счёт игры
     *
     * Целое неотрицательное число, представляющее текущий счёт игрока.
     * Правила начисления очков зависят от игры:
     * - Tetris: очки начисляются за очистку строк
     * - Snake: очки начисляются за поедание еды
     * - Racing: очки на основе расстояния/скорости
     *
     * Диапазон: 0 до 2,147,483,647 (2^31 - 1, максимальный int)
     *
     * Должен отображаться в боковой панели GUI.
     */
    int score;

    /**
     * @brief Максимальный счёт, когда-либо достигнутый
     *
     * Целое неотрицательное число, представляющее лучший счёт игрока.
     * Это значение сохраняется между сеансами игры и загружается из
     * файла конфигурации при запуске игры.
     *
     * Диапазон: 0 до 2,147,483,647 (2^31 - 1, максимальный int)
     *
     * Должен отображаться в боковой панели GUI и обновляться,
     * когда текущий счёт превышает это значение.
     */
    int high_score;

    /**
     * @brief Текущий уровень игры
     *
     * Целое число, представляющее текущий уровень игры.
     * Влияет на сложность игры (обычно: более высокий уровень = быстрая игра).
     *
     * Диапазон: Обычно 1-10, но может быть расширен
     * - Tetris: уровни 1-10, скорость увеличивается с уровнем
     * - Snake: аналогичная прогрессия
     *
     * Уровень может увеличиваться:
     * - Автоматически при достижении порогов счёта
     * - Вручную выбором игрока
     * - Через бонусы или события в игре
     *
     * Должен отображаться в боковой панели GUI.
     */
    int level;

    /**
     * @brief Параметр скорости игры
     *
     * Представляет скорость игры, обычно измеряется в миллисекундах
     * на игровое действие (например, миллисекунды на опускание ряда в Tetris).
     *
     * Меньшие значения = более быстрая игра
     * Примеры значений:
     * - Уровень 1: 800мс на опускание
     * - Уровень 5: 400мс на опускание
     * - Уровень 10: 100мс на опускание
     *
     * Используется GUI для определения частоты обновления и визуальных эффектов.
     * Должен отображаться в боковой панели GUI.
     */
    int speed;

    /**
     * @brief Флаг паузы
     *
     * Целое число, указывающее, находится ли игра на паузе:
     * - 0: игра запущена (играет)
     * - 1: игра на паузе
     *
     * Когда игра на паузе:
     * - Логика игры не должна продвигаться вперёд
     * - GUI должна отображать наложение "ПАУЗА" или индикатор
     * - Пользовательский ввод (кроме возобновления) должен игнорироваться
     *
     * Пример использования в C:
     * @code
     * GameInfo_t state = updateCurrentState();
     * if (state.pause == 1) {
     *     display_pause_screen();
     * }
     * @endcode
     */
    int pause;

} GameInfo_t;

/**
 * @brief Обработка пользовательского ввода
 *
 * Эта функция обрабатывает весь пользовательский ввод с физических кнопок
 * консоли. Она должна вызываться слоем GUI при каждом нажатии или отпускании
 * кнопки.
 *
 * Функция синхронная и должна вернуться немедленно. Долгие операции должны
 * быть отложены на updateCurrentState() или фоновый поток.
 *
 * @param action Действие пользователя (см. перечисление UserAction_t)
 * @param hold   Флаг удержания клавиши:
 *               - true:  Клавиша удерживается (непрерывное нажатие)
 *               - false: Клавиша отпущена (одиночное нажатие)
 *
 * Типичное использование при нажатии/отпускании кнопки:
 * @code
 * // Пользователь нажимает кнопку "Влево"
 * userInput(Left, true);
 *
 * // Пользователь удерживает кнопку "Влево"
 * // (может вызваться повторно, пока кнопка удерживается)
 * userInput(Left, true);
 *
 * // Пользователь отпускает кнопку "Влево"
 * userInput(Left, false);
 * @endcode
 *
 * Поведение игры:
 * - Start: переход из состояния Start в состояние выполнения
 * - Pause: переключение паузы/возобновления
 * - Terminate: выход в состояние Game Over
 * - Left: движение активной фигуры влево (Tetris)
 * - Right: движение активной фигуры вправо (Tetris)
 * - Up: не используется в Tetris, доступно для других игр
 * - Down: движение активной фигуры вниз или ускорение (Tetris)
 * - Action: выполнить действие, зависящее от игры (вращение в Tetris)
 *
 * @note Эта функция может модифицировать внутреннее состояние игры через
 *       механизм FSM (конечный автомат).
 *
 * @note Реализация должна быть потокобезопасна при вызове из нескольких потоков.
 *
 * @see updateCurrentState()
 */
void userInput(UserAction_t action, bool hold);

/**
 * @brief Получить текущее состояние игры для отрисовки
 *
 * Эта функция возвращает полное текущее состояние игры. Она должна вызываться
 * слоем GUI периодически (обычно 30-60 раз в секунду) для обновления дисплея.
 *
 * Функция возвращает всю информацию, необходимую для отрисовки игры:
 * - Состояние игрового поля (field)
 * - Превью следующего предмета (next)
 * - Счёт и рекордный счёт
 * - Уровень и скорость
 * - Статус паузы
 *
 * Реализация игры ответственна за:
 * - Выделение памяти для field и next (через updateCurrentState или раньше)
 * - Сохранение этих указателей в допустимом состоянии на весь период игры
 * - Обновление field и next на основе логики игры
 *
 * Типичное использование:
 * @code
 * while (game_running) {
 *     GameInfo_t state = updateCurrentState();
 *
 *     // Отрисовка игрового поля
 *     for (int i = 0; i < FIELD_HEIGHT; i++) {
 *         for (int j = 0; j < FIELD_WIDTH; j++) {
 *             if (state.field[i][j] == 1) {
 *                 render_filled_cell(i, j);
 *             }
 *         }
 *     }
 *
 *     // Отрисовка информационной панели
 *     render_score(state.score);
 *     render_level(state.level);
 *
 *     // Проверка статуса паузы
 *     if (state.pause == 1) {
 *         render_pause_overlay();
 *     }
 *
 *     usleep(16667);  // ~60 FPS
 * }
 * @endcode
 *
 * @return Структура GameInfo_t, содержащая текущее состояние игры
 *
 * @note Возвращаемая структура содержит указатели на внутренние данные игры.
 *       Слой GUI не должен модифицировать эти указатели или их содержимое.
 *       Не вызывайте free() для указателей, возвращённых этой функцией.
 *
 * @note Возвращаемое состояние - это снимок на момент вызова. При следующих
 *       вызовах могут быть возвращены разные значения, если состояние изменилось.
 *
 * @note Эта функция может также обрабатывать автоматические обновления игры
 *       (например, падение блоков в Tetris) на основе прошедшего времени
 *       с момента последнего вызова.
 *
 * @see userInput()
 */
GameInfo_t updateCurrentState(void);

#ifdef __cplusplus
}
#endif

#endif /* BRICKGAME_H */