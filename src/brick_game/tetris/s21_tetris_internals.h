#ifndef S21_TETRIS_INTERNALS_H_
#define S21_TETRIS_INTERNALS_H_

#include <stdbool.h>

#include "s21_bgame.h"  // GameInfo_t, GameId_t, UserAction_t, fsm_t и пр.
#include "s21_fsm.h"    // fsm_t

/* ---------------------- Константы и данные фигур ---------------------- */

/**
 * @def TETRIS_NUM_PIECES
 * @brief Количество уникальных типов фигур (тетромино) в игре Тетрис
 *
 * Определяет количество стандартных тетромино в классическом Тетрисе: I, O, T,
 * S, Z, J, L — всего 7. Это значение используется для:
 * - индексации массива TETROMINO_DATA,
 * - генерации случайных фигур,
 * - выделения памяти и проверки границ.
 *
 * @note Значение жёстко привязано к реализации TETROMINO_DATA. Его изменение
 * без синхронного обновления массива фигур приведёт к неопределённому поведению
 * (выход за границы массива).
 *
 * @warning Не используйте это значение как тип фигуры напрямую. Используйте
 * перечисление TetrominoType, если требуется типобезопасность и читаемость
 * кода.
 *
 * @see TETROMINO_DATA, TetrominoType
 */
#define TETRIS_NUM_PIECES 7

/**
 * @def TETRIS_ROTATIONS
 * @brief Количество уникальных поворотов (ротаций) для каждой фигуры в Тетрисе
 *
 * Определяет число возможных ориентаций тетромино: 0°, 90°, 180° и 270° —
 * всего 4. Используется как размер второго измерения в массиве TETROMINO_DATA и
 * при вычислении индексов поворотов по модулю 4.
 *
 * @details
 * - Все фигуры используют одинаковое количество поворотов, даже если визуально
 *   некоторые состояния идентичны (например, O-фигура).
 * - Это обеспечивает единый интерфейс доступа к данным фигур через
 * tetris_getPieceData().
 *
 * @note При вращении фигуры новый индекс поворота вычисляется по формуле:
 *       <code>rotation = (rotation + direction) % TETRIS_ROTATIONS</code>.
 *       Гарантируется корректная работа с отрицательными значениями за счёт
 * коррекции.
 *
 * @warning Не изменяйте значение этой константы без одновременного обновления
 *          массива TETROMINO_DATA и логики поворота. Несоответствие приведёт
 *          к выходу за границы массива и неопределённому поведению.
 *
 * @see TETROMINO_DATA, tetris_rotate_piece(), tetris_getPieceData()
 */
#define TETRIS_ROTATIONS 4

/**
 * @def TETRIS_FIELD_ROWS
 * @brief Высота игрового поля Тетриса — количество строк
 *
 * Определяет число строк в игровом поле. Стандартное значение — 20.
 * Строки нумеруются от 0 (сверху) до 19 (снизу). Фигуры появляются в верхних
 * строках (0 и 1), которые считаются "невидимой зоной", но участвуют в проверке
 * коллизий при спавне.
 *
 * Используется для:
 * - выделения памяти под игровое поле,
 * - проверки выхода за границы по вертикали,
 * - определения условий завершения игры (если новая фигура пересекает верхние
 * строки),
 * - реализации логики очистки линий.
 *
 * @note
 * - Значение соответствует классическому варианту Тетриса (например, по
 * стандарту Tetris Guideline).
 * - Изменение размера поля требует пересмотра:
 *   - логики инициализации поля,
 *   - условий проигрыша,
 *   - стратегии генерации и размещения фигур,
 *   - тестов, зависящих от фиксированной высоты.
 * - Используется в выражениях вида <code>row < TETRIS_FIELD_ROWS</code> —
 *   гарантирует корректность итераций и доступа к массиву.
 *
 * @warning Несинхронное изменение этой константы и TETRIS_FIELD_COLS, а также
 *          функций, использующих жёсткую индексацию (например, spawn или
 * collision check), приведёт к неопределённому поведению, включая выход за
 * границы массива.
 *
 * @see TETRIS_FIELD_COLS, tetris_check_collision(), tetris_spawn_piece(),
 * tetris_clear_lines()
 */
#define TETRIS_FIELD_ROWS BGAME_FIELD_HEIGHT

/**
 * @def TETRIS_FIELD_COLS
 * @brief Ширина игрового поля Тетриса — количество столбцов
 *
 * Определяет число столбцов в игровом поле. Стандартное значение — 10.
 * Столбцы нумеруются от 0 (слева) до 9 (справа). Используется при выделении
 * памяти для двумерного массива поля, проверке границ и коллизий, а также при
 * расчёте позиций фигур и их поворотов.
 *
 * Является частью классического формата игрового поля (10×20), принятого в
 * Tetris Guideline. Изменение значения влияет на геймплей, включая сложность
 * размещения и стратегию игры.
 *
 * @note
 * - Используется в циклах вида <code>col < TETRIS_FIELD_COLS</code> —
 *   гарантирует корректный обход по горизонтали.
 * - Все проверки выхода за границы (например, при движении или повороте)
 *   зависят от этого значения.
 * - Несмотря на стандарт, некоторые режимы могут использовать другие размеры,
 *   но в этом случае требуется изолированная логика инициализации и отрисовки.
 *
 * @warning
 * - Изменение константы без синхронного обновления:
 *   - массива игрового поля,
 *   - функций проверки коллизий (tetris_check_collision),
 *   - логики поворота (tetris_rotate_piece),
 *   - инициализации и отрисовки,
 *   — приведёт к выходу за границы массива и неопределённому поведению.
 * - Убедитесь, что все зависимости обновлены при модификации.
 *
 * @see TETRIS_FIELD_ROWS, tetris_check_collision(), tetris_rotate_piece(),
 * tetris_draw_field()
 */
#define TETRIS_FIELD_COLS BGAME_FIELD_WIDTH

/**
 * @def TETRIS_PIECE_SIZE
 * @brief Размер блока тетромино — сторона квадратной матрицы формы фигуры
 *
 * Определяет размерность квадратного шаблона (матрицы) для представления формы
 * тетромино — 4×4. Хотя большинство фигур занимают меньше ячеек, используется
 * фиксированный размер 4, чтобы вместить самую крупную ориентацию (например,
 * I-фигуру в вертикальном положении).
 *
 * Используется:
 * - как размер матрицы данных в TETROMINO_DATA,
 * - при копировании формы фигуры на игровое поле,
 * - в проверках коллизий и поворотов,
 * - для выделения временных буферов под фигуры.
 *
 * @note
 * - Значение 4 выбрано из соображений совместимости с классическим Тетрисом и
 * упрощения индексации.
 * - Все фигуры нормализованы к 4×4, даже если фактически используют меньше
 * ячеек.
 * - Используется в выражениях вида <code>for (int i = 0; i < TETRIS_PIECE_SIZE;
 * i++)</code>, что обеспечивает независимость от "магических чисел".
 *
 * @warning
 * - Изменение значения без переработки TETROMINO_DATA приведёт к несоответствию
 * данных и выходу за границы массива.
 * - Функции, полагающиеся на жёсткий размер (например, отрисовка или
 * копирование), могут работать некорректно при модификации.
 *
 * @see TETROMINO_DATA, TETRIS_NUM_PIECES, TETRIS_ROTATIONS,
 * tetris_check_collision()
 */
#define TETRIS_NEXT_SIZE 4

/**
 * @def TETRIS_SCORE_DIR
 * @brief Имя директории для хранения файлов с информацией о счёте и рекордах
 *
 * Определяет название скрытой директории в домашнем каталоге пользователя
 * (обычно ~/.brickgame), где сохраняются файлы с данными о рекордах, настройках
 * или состоянии игры.
 *
 * Используется при генерации путей к файлам, например:
 * - ~/.brickgame/score.txt — хранение максимального счёта,
 * - ~/.brickgame/config.ini — сохранение пользовательских настроек.
 *
 * @note
 * - Директория скрытая (начинается с точки), что соответствует
 * Unix-соглашениям.
 * - При запуске игра проверяет наличие директории и создаёт её, если она
 * отсутствует.
 * - Использование домашнего каталога обеспечивает изоляцию данных пользователя
 *   и совместимость с многопользовательскими системами.
 *
 * @warning
 * - Изменение имени директории может привести к потере доступа к существующим
 * данным.
 * - Убедитесь, что у приложения есть права на чтение/запись в эту директорию.
 *
 * @see tetris_load_score(), tetris_save_score(), tetris_ensure_config_dir()
 */
#define TETRIS_SCORE_DIR ".brickgame"

/**
 * @def TETRIS_SCORE_FILE
 * @brief Полный путь к файлу сохранения рекорда игры Тетрис
 *
 * Определяет путь к файлу, в котором хранится значение максимального счёта
 * (рекорда). Файл располагается в директории, заданной константой
 * TETRIS_SCORE_DIR. Пример полного пути:
 * <code>~/.brickgame/tetris.score</code>.
 *
 * Используется функциями:
 * - tetris_load_score() — для чтения текущего рекорда при запуске игры,
 * - tetris_save_score() — для сохранения нового рекорда по завершению сессии.
 *
 * @note
 * - Файл создаётся автоматически, если не существует.
 * - Содержимое файла — текстовое значение счётчика (целое число), например:
 * <code>12500</code>.
 * - Использование относительного пути через TETRIS_SCORE_DIR обеспечивает
 * переносимость и централизованное управление расположением пользовательских
 * данных.
 *
 * @warning
 * - Прямое удаление или редактирование файла пользователем приведёт к сбросу
 * или изменению рекорда.
 * - Убедитесь, что директория TETRIS_SCORE_DIR существует перед попыткой
 * записи.
 *
 * @see TETRIS_SCORE_DIR, tetris_load_score(), tetris_save_score(),
 * tetris_ensure_config_dir()
 */
#define TETRIS_SCORE_FILE TETRIS_SCORE_DIR "/tetris.score"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @var TETROMINO_DATA
 * @brief Глобальный массив форм тетромино для всех типов и поворотов
 *
 * Статический массив данных, содержащий бинарные формы семи стандартных фигур
 * Тетриса (I, O, T, S, Z, J, L) в четырёх ориентациях каждая (0°, 90°, 180°,
 * 270°). Каждая фигура представлена матрицей 4×4 типа `unsigned char`, где:
 * - значение 0 — пустая ячейка (отсутствие блока),
 * - значения 1–7 — идентификатор фигуры (используется для отрисовки и логики).
 *
 * Массив объявлен как `extern const`, что означает:
 * - его определение находится в s21_tetris_pieces.c,
 * - он доступен только для чтения (размещается в .rodata),
 * - не может быть изменён во время выполнения.
 *
 * @details
 * - Первое измерение: тип фигуры, диапазон [0, TETRIS_NUM_PIECES - 1].
 * - Второе измерение: поворот, диапазон [0, TETRIS_ROTATIONS - 1].
 * - Третье и четвёртое измерения: строка и столбец в шаблоне 4×4
 * (TETRIS_PIECE_SIZE).
 *
 * @note
 * - Все данные нормализованы к размеру 4×4, даже если фигура занимает меньше
 * ячеек.
 * - Порядок фигур соответствует перечислению TetrominoType (если используется).
 *
 * @warning
 * - Любое изменение размерности или содержимого массива должно сопровождаться
 *   обновлением связанных констант: TETRIS_NUM_PIECES, TETRIS_ROTATIONS,
 * TETRIS_PIECE_SIZE.
 * - Нарушение порядка фигур или поворотов приведёт к визуальным и логическим
 * ошибкам.
 *
 * @see tetris_getPieceData(), TETRIS_NUM_PIECES, TETRIS_ROTATIONS,
 * TETRIS_PIECE_SIZE, s21_tetris_pieces.c
 */
extern const int TETROMINO_DATA[TETRIS_NUM_PIECES][TETRIS_ROTATIONS][4][4];

/**
 * @brief Возвращает указатель на матрицу формы тетромино по типу и повороту
 *
 * Функция предоставляет безопасный доступ к данным формы фигуры из глобального
 * массива TETROMINO_DATA. Принимает тип фигуры и её поворот, возвращает
 * указатель на 4×4 матрицу, где каждый элемент равен 0 (пустая ячейка) или
 * значению типа фигуры (1–7).
 *
 * @param[in]  type       Тип фигуры: значение от 0 до TETRIS_NUM_PIECES - 1
 * @param[in]  rotation   Поворот: значение от 0 до TETRIS_ROTATIONS - 1 (0°,
 * 90°, 180°, 270°)
 * @return                Указатель на массив типа `const int (*)[4]`,
 * содержащий форму, или NULL, если переданы некорректные параметры
 *
 * @details
 * Возвращаемый тип — указатель на массив из 4 элементов типа `const int`,
 * что позволяет использовать результат как двумерный массив:
 * @code
 * const int (*shape)[4] = tetris_getPieceData(type, rotation);
 * if (shape) {
 *     for (int i = 0; i < TETRIS_PIECE_SIZE; ++i) {
 *         for (int j = 0; j < TETRIS_PIECE_SIZE; ++j) {
 *             if (shape[i][j]) {
 *                 // Рисуем блок фигуры
 *             }
 *         }
 *     }
 * }
 * @endcode
 *
 * @note
 * - Всегда проверяйте возвращаемое значение на NULL перед использованием.
 * - Функция потокобезопасна — не изменяет состояние и работает только с
 * константными данными.
 * - Для корректной работы требует, чтобы TETROMINO_DATA был правильно
 * инициализирован.
 *
 * @warning
 * - Возвращаемые данные доступны только для чтения (расположены в .rodata).
 * - Не пытайтесь изменять или освобождать память, на которую указывает
 * возвращаемое значение.
 *
 * @see TETROMINO_DATA, TETRIS_NUM_PIECES, TETRIS_ROTATIONS, TETRIS_PIECE_SIZE
 */
const int (*tetris_getPieceData(int type, int rotation))[4];

/* ----------------------------- Типы FSM ------------------------------- */

/**
 * @enum TetrisState
 * @brief Состояния конечного автомата (FSM) игры Тетрис
 *
 * Перечисление определяет все фазы работы игрового автомата. Используется
 * функцией `tetris_fsm_dispatch()` для управления потоком выполнения игры
 * в ответ на события (ввод, таймер, завершение и т.д.).
 *
 * Каждое состояние:
 * - определяет, какие события обрабатываются,
 * - задаёт поведение на входе/выходе (через колбэки, если используется
 * расширенный FSM),
 * - влияет на отрисовку и реакцию на пользовательский ввод.
 *
 * @details
 * - Значения используются как индексы в таблице переходов `tetris_transitions`.
 * - Порядок элементов **может быть значимым** при инициализации массивов.
 * - `TETRIS_STATE_MAX` служит счётчиком количества состояний и **должен
 * оставаться последним**.
 *
 * @note
 * - Для проверки валидности состояния используйте:
 *   <code>state >= TETRIS_STATE_INIT && state < TETRIS_STATE_MAX</code>.
 * - Не переставляйте и не вставляйте элементы без обновления таблицы переходов.
 *
 * @warning Изменение порядка или вставка новых состояний без корректировки
 *          `tetris_transitions[]` приведёт к неправильным переходам и сбоям.
 *
 * @see TetrisEvent, tetris_fsm_dispatch, tetris_transitions, fsm_t
 */
typedef enum {
  TETRIS_STATE_INIT =
      0,  ///< Инициализация игры: сброс всех данных, подготовка к старту
  TETRIS_STATE_SPAWN,  ///< Спавн новой фигуры: подготовка `current` фигуры из
                       ///< `next`
  TETRIS_STATE_FALL,  ///< Активное падение фигуры: обработка ввода (движение,
                      ///< поворот)
  TETRIS_STATE_LOCK,  ///< Фиксация фигуры: размещение в поле, проверка линий,
                      ///< обновление счёта
  TETRIS_STATE_GAME_OVER,  ///< Состояние окончания игры: отображение
                           ///< результатов, ожидание рестарта
  TETRIS_STATE_PAUSED,  ///< Пауза: приостановка игрового процесса, ожидание
                        ///< продолжения
  TETRIS_STATE_MAX  ///< Служебное значение: количество состояний (для валидации
                    ///< и циклов)
} TetrisState;

/**
 * @enum TetrisEvent
 * @brief События конечного автомата (FSM) игры Тетрис
 *
 * Перечисление определяет все возможные события, вызывающие переходы
 * между состояниями в игровом FSM. События генерируются:
 * - пользовательским вводом (клавиши движения, поворота, паузы),
 * - таймером (тик падения),
 * - внутренней логикой игры (фиксация фигуры, проверка проигрыша).
 *
 * Используется совместно с `TetrisState` и `tetris_fsm_dispatch()` для
 * управления потоком выполнения. Каждое событие обрабатывается в контексте
 * текущего состояния — если переход не определён, событие игнорируется.
 *
 * @details
 * - Значения используются как индексы в таблице переходов `tetris_transitions`.
 * - Порядок важен при инициализации массивов; `TETRIS_EVT_MAX` должен
 * оставаться последним.
 *
 * @note
 * - `TETRIS_EVT_NONE` используется для немедленных или условных переходов
 *   (например, проверка коллизии после спавна).
 * - События не блокирующие: каждое обрабатывается за один шаг игры.
 *
 * @warning
 * - Не изменяйте порядок или добавляйте значения без обновления
 * `tetris_transitions[]`.
 * - Несоответствие между количеством событий и размером таблицы приведёт к
 * сбоям FSM.
 *
 * @see TetrisState, tetris_fsm_dispatch, tetris_transitions,
 * tetris_handle_input, tetris_update
 */
typedef enum {
  TETRIS_EVT_NONE = 0,  ///< Пустое событие — используется для внутренних
                        ///< переходов без внешнего триггера
  TETRIS_EVT_START,  ///< Событие старта или перезапуска игры
  TETRIS_EVT_TICK,  ///< Игровой тик: регулярное событие от таймера (вызывается
                    ///< из `tetris_update`)
  TETRIS_EVT_MOVE_LEFT,  ///< Попытка сдвинуть фигуру влево
  TETRIS_EVT_MOVE_RIGHT,  ///< Попытка сдвинуть фигуру вправо
  TETRIS_EVT_MOVE_DOWN,  ///< Попытка сдвинуть фигуру вниз на одну строку (soft
                         ///< drop)
  TETRIS_EVT_DROP,  ///< Мгновенное падение фигуры до нижней позиции (hard drop)
  TETRIS_EVT_ROTATE,  ///< Попытка повернуть текущую фигуру
  TETRIS_EVT_PAUSE_TOGGLE,  ///< Переключение состояния паузы (вкл/выкл)
  TETRIS_EVT_TERMINATE,  ///< Принудительное завершение игры (выход)
  TETRIS_EVT_MAX  ///< Служебное значение: количество событий (для валидации и
                  ///< циклов)
} TetrisEvent;

/* ---------------------------- Структуры ------------------------------- */

/**
 * @struct TetrisPiece
 * @brief Структура, описывающая состояние тетромино (игровой фигуры)
 *
 * Хранит всю необходимую информацию о фигуре: её тип, текущую ориентацию
 * и позицию на игровом поле. Используется для представления активной
 * (`current`) и предварительной (`next`) фигур в экземпляре TetrisGame.
 *
 * @details
 * - Поле `type` определяет форму фигуры (I, O, T и т.д.) и индексирует
 * TETROMINO_DATA.
 * - Поле `rotation` определяет ориентацию (0–3), соответствует
 * TETRIS_ROTATIONS.
 * - Координаты `x` и `y` задают положение верхнего левого угла
 *   ограничивающего квадрата 4×4 фигуры.
 *
 * @note
 * - Координаты указаны в индексах поля: (0,0) — левый верхний угол.
 * - Отрицательные значения `y` допустимы и используются при спавне фигуры
 *   (например, y = -1 или y = -2), что соответствует "невидимой зоне" над
 * полем.
 * - Структура не хранит цвет или визуальное представление — они выводятся из
 * `type`.
 *
 * @warning
 * - Значения `type` и `rotation` должны быть валидными: выход за границы
 *   приведёт к неопределённому поведению при доступе к TETROMINO_DATA.
 * - При изменении структуры убедитесь, что она остаётся POD-типа
 *   (Plain Old Data) для предсказуемого копирования.
 *
 * @see TetrisGame, TETROMINO_DATA, TETRIS_NUM_PIECES, TETRIS_ROTATIONS
 */
typedef struct {
  int type;  ///< Тип фигуры: значение от 0 до TETRIS_NUM_PIECES-1
  int rotation;  ///< Текущий поворот фигуры (0–3): 0°, 90°, 180°, 270°
  int x;  ///< Горизонтальная позиция (столбец) на игровом поле
  int y;  ///< Вертикальная позиция (строка) на игровом поле
} TetrisPiece;

/**
 * @struct TetrisGame
 * @brief Основная структура состояния игры Тетрис
 *
 * Содержит полный контекст игрового процесса: игровое поле, активную и
 * следующую фигуры, счёт, уровень, таймер и логику состояний (FSM). Является
 * центральной структурой, управляющей всем поведением игры.
 *
 * @details
 * - Поле @p info предназначено для экспорта состояния в UI через
 * tetris_get_info().
 * - Внутренние поля (@p field_storage, @p next_storage, @p fsm) используются
 *   для управления памятью и логикой, недоступны извне.
 * - Все координаты и индексы используют нумерацию с нуля.
 *
 * @note
 * - Структура не инициализируется нулём автоматически — всегда вызывайте
 * tetris_game_create().
 * - После создания должна быть уничтожена через tetris_game_destroy() для
 * корректного освобождения памяти.
 * - Поля @p info.field и @p info.next указывают на выделенные блоки памяти
 *   (@p field_storage и @p next_storage соответственно).
 *
 * @warning
 * - Прямое копирование структуры (по значению) приведёт к двойному освобождению
 * памяти.
 * - Не модифицируйте поля @p info напрямую — используйте внутренние функции.
 * - Нарушение порядка инициализации/уничтожения вызовет утечки или ошибки
 * доступа.
 *
 * @see tetris_game_create(), tetris_game_destroy(), tetris_get_info(),
 * GameInfo_t, fsm_t
 */
typedef struct TetrisGame {
  GameInfo_t
      info;  ///< Публичное состояние игры, доступное через tetris_get_info()
  int **field_storage;  ///< Динамический буфер поля размером TETRIS_FIELD_ROWS
                        ///< x TETRIS_FIELD_COLS
  int **next_storage;  ///< Динамический буфер превью размером TETRIS_NEXT_SIZE
                       ///< x TETRIS_NEXT_SIZE
  TetrisPiece current;  ///< Текущая активная фигура, падающая на поле
  TetrisPiece next;  ///< Следующая фигура, отображаемая в превью
  int lines_cleared;  ///< Общее количество очищенных линий за игру
  bool game_over;  ///< Флаг окончания игры: true, если текущая партия завершена
  bool started;  ///< Флаг, указывающий, была ли игра запущена хотя бы раз
  int high_score;  ///< Хранение рекорда между сессиями (дублирует
                   ///< info.high_score)
  fsm_t fsm;  ///< Конечный автомат для управления состояниями игры
} TetrisGame;

/* --------------------- Жизненный цикл модели ------------------------- */

/**
 * @brief Создаёт и полностью инициализирует новый экземпляр игры Тетрис
 *
 * Выделяет память под структуру TetrisGame и все связанные ресурсы:
 * - Внутреннее игровое поле (field_storage),
 * - Буфер для отображения (info.field),
 * - Буфер предварительного просмотра следующей фигуры (next_storage).
 *
 * Также:
 * - Загружает максимальный счёт из файла,
 * - Сбрасывает игровое состояние (счёт, уровень, фигуры) через
 * tetris_game_reset(),
 * - Инициализирует FSM в начальном состоянии.
 *
 * @return Указатель на инициализированный объект TetrisGame при успехе;
 *         NULL, если выделение памяти не удалось.
 *
 * @details
 * - Память под структуру выделяется через calloc(), что гарантирует обнуление
 * всех полей.
 * - Все матрицы создаются через tetris_alloc_matrix(), которая также использует
 * calloc().
 * - При неудаче на любом этапе вызывается tetris_game_destroy(), обеспечивая
 *   корректное освобождение всех уже выделенных ресурсов (отсутствие утечек).
 *
 * @note
 * - Результат требует освобождения через tetris_game_destroy().
 * - После успешного создания игра готова к обработке событий.
 * - Функция зависит только от глобальных констант и файла рекордов
 * (TETRIS_SCORE_FILE).
 *
 * @warning
 * - При нехватке памяти возвращает NULL — всегда проверяйте возвращаемое
 * значение.
 * - Не является потокобезопасной: параллельные вызовы могут конфликтовать при
 * доступе к файлу рекорда.
 * - Размеры TETRIS_FIELD_ROWS, TETRIS_FIELD_COLS и TETRIS_NEXT_SIZE напрямую
 * влияют на объём выделяемой памяти — убедитесь, что они разумны для целевой
 * платформы.
 *
 * @see tetris_game_destroy(), tetris_game_reset(), tetris_load_high_score(),
 * TetrisGame
 */
TetrisGame *tetris_game_create(void);

/**
 * @brief Освобождает ресурсы, связанные с экземпляром игры Тетрис
 *
 * Полностью деинициализирует и освобождает память, выделенную для объекта
 * TetrisGame и всех вложенных динамических ресурсов. Перед уничтожением
 * сохраняет текущий рекорд, если он превышает сохранённый в файле.
 *
 * @param[in] game Указатель на объект TetrisGame. Допускается NULL — в этом
 * случае функция не выполняет действий.
 *
 * @details
 * - При передаче NULL функция немедленно завершается — поведение безопасно.
 * - Вызывает tetris_save_high_score() для сохранения счёта, если он является
 * новым рекордом.
 * - Последовательно освобождает все матрицы:
 *   - game->field_storage — внутреннее представление игрового поля,
 *   - game->next_storage  — буфер следующей фигуры,
 *   - game->info.field    — копия поля для внешнего доступа.
 *   Освобождение выполняется через tetris_free_matrix() с корректным указанием
 * числа строк.
 * - После освобождения всех ресурсов освобождается сам объект game через
 * free().
 *
 * @note
 * - Должна вызываться ровно один раз для каждого объекта, созданного через
 * tetris_game_create().
 * - Не изменяет значение указателя game (не устанавливает в NULL) — это
 * остаётся на усмотрение вызывающего кода.
 * - Обеспечивает полное освобождение ресурсов, включая защиту от утечек при
 * частичной инициализации.
 *
 * @warning
 * - Повторный вызов с тем же указателем (double free) приводит к
 * неопределённому поведению.
 * - Несоблюдение порядка: destroy → create → destroy — может вызвать утечки или
 * сбои.
 * - Не является потокобезопасной: одновременный доступ к одному объекту game из
 * разных потоков опасен.
 *
 * @see tetris_game_create(), tetris_save_high_score(), tetris_free_matrix()
 */
void tetris_game_destroy(TetrisGame *game);

/**
 * @brief Сбрасывает состояние игры Тетрис к начальному
 *
 * Полностью переинициализирует все игровые данные: счёт, уровень, количество
 * очищенных линий, игровое поле, текущую и следующую фигуры. Устанавливает FSM
 * в состояние TETRIS_STATE_INIT.
 *
 * @param[in] game Указатель на объект TetrisGame. Может быть NULL — в этом
 * случае функция не выполняет действий.
 *
 * @details
 * - При передаче NULL функция немедленно завершается — поведение безопасно.
 * - Явный вызов on_enter_init((fsm_context_t)game) гарантирует:
 *   - обнуление счёта и уровня,
 *   - очистку игрового поля,
 *   - корректную инициализацию начальных значений.
 *   Это необходимо, потому что fsm_init() сам по себе не вызывает on_enter.
 * - После инициализации FSM через fsm_init() игра готова к обработке событий
 * (например, TETRIS_EVT_START).
 *
 * @note
 * - Вызывается как при первом создании игры (в tetris_game_create), так и при
 * перезапуске после GAME_OVER.
 * - Гарантирует детерминированное начальное состояние: счёт = 0, уровень = 1,
 * поле пусто.
 * - Не выделяет и не освобождает память — работает только с уже выделёнными
 * ресурсами.
 *
 * @warning
 * - Не проверяет целостность структуры game — ожидается, что game и её поля
 * (например, field_storage) валидны.
 * - Для полного пересоздания игры используйте пару: tetris_game_destroy() +
 * tetris_game_create().
 *
 * @see tetris_game_create(), on_enter_init(), fsm_init(), TetrisGame
 */
void tetris_game_reset(TetrisGame *game);

/* ------------------------ Поле и превью ------------------------------ */

/**
 * @brief Очищает игровое поле, устанавливая все ячейки в ноль
 *
 * Полностью обнуляет содержимое как внутреннего буфера игрового поля
 * (field_storage), так и внешнего представления (info.field). Гарантирует
 * чистое состояние поля перед началом новой игры или спавном фигуры.
 *
 * @param[in] game Указатель на объект TetrisGame. Допускается NULL — в этом
 * случае функция не выполняет действий.
 *
 * @details
 * - Если game == NULL, или если game->field_storage / game->info.field не
 * инициализированы, функция немедленно завершается — поведение безопасно.
 * - Обнуление выполняется построчно и поэлементно с использованием вложенных
 * циклов.
 * - Циклы используют глобальные константы TETRIS_FIELD_ROWS и
 * TETRIS_FIELD_COLS, что исключает "магические числа" и обеспечивает
 * согласованность.
 *
 * @note
 * - Функция не изменяет логическое состояние игры (счёт, уровень, фигуры и
 * т.д.) — только визуальное и внутреннее представление поля.
 * - Должна вызываться только при корректно выделенной памяти под оба буфера.
 * - Используется в критических точках: инициализация, сброс игры, обработка
 * завершения.
 * - Сложность O(n×m) — допустима, так как вызывается редко и на небольших
 * объёмах данных (20×10).
 *
 * @warning
 * - Не освобождает память — только устанавливает значения ячеек в 0.
 * - Не проверяет целостность структуры game — ожидается, что все поля, на
 * которые есть ссылки, инициализированы до вызова.
 *
 * @see tetris_game_reset(), tetris_game_create(), tetris_clear_full_lines()
 */
void tetris_clear_field(TetrisGame *game);

/**
 * @brief Очищает буфер предпросмотра следующей фигуры
 *
 * Обнуляет все ячейки внутреннего буфера `next_storage`, используемого для
 * визуального представления следующей фигуры. После вызова буфер становится
 * пустым — на экране не будет отображаться никакая фигура до обновления через
 * tetris_update_next_preview().
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL.
 *                 Если game или game->next_storage не инициализированы, функция
 * безопасно завершается.
 *
 * @details
 * - Функция модифицирует только `game->next_storage` — логическое состояние
 * `game->next` (тип, поворот, координаты) остаётся неизменным.
 * - Обнуление необходимо перед обновлением превью, чтобы избежать артефактов от
 * предыдущего отображения.
 * - Выполняется через вложенные циклы по размеру TETRIS_NEXT_SIZE (обычно 4×4).
 *
 * @note
 * - `info.next` в структуре GameInfo_t ссылается на тот же буфер
 * `next_storage`, поэтому изменения отображаются автоматически через интерфейс.
 * - Вызывается при сбросе игры, генерации новой фигуры и перед обновлением
 * превью.
 * - Сложность O(n²) — незначительна из-за малого размера буфера.
 *
 * @warning Не освобождает память — только обнуляет содержимое.
 *          Не влияет на логику игры, только на визуализацию.
 *
 * @see tetris_update_next_preview(), tetris_clear_field(),
 * tetris_spawn_piece(), tetris_generate_next_piece()
 */
void tetris_clear_next(TetrisGame *game);

/**
 * @brief Обновляет буфер предпросмотра следующей фигуры
 *
 * Копирует форму фигуры из `game->next` в буфер `next_storage` для визуального
 * отображения в интерфейсе. Перед копированием выполняет очистку буфера, чтобы
 * избежать артефактов. Используется после генерации новой фигуры или при
 * перерисовке превью.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL.
 *                 Если game, game->next_storage или данные фигуры
 * (type/rotation) некорректны, функция безопасно завершается без изменений.
 *
 * @details
 * - Сначала вызывается tetris_clear_next() для обнуления буфера.
 * - Форма фигуры извлекается через tetris_getPieceData(game->next.type,
 * game->next.rotation).
 * - Данные копируются в `next_storage` поэлементно: для каждой ячейки, где
 * значение > 0, оно записывается в соответствующую позицию буфера (с учётом
 * размера TETRIS_NEXT_SIZE).
 * - Поскольку `info.next` указывает на `next_storage`, обновление автоматически
 * доступно через интерфейс GameInfo_t.
 *
 * @note
 * - Функция влияет только на визуализацию — логическое состояние `game->next`
 * остаётся неизменным.
 * - Должна вызываться каждый раз при изменении следующей фигуры (например,
 * после tetris_generate_next_piece).
 * - Гарантирует актуальное и корректное отображение в UI без "мусора" от
 * предыдущих фигур.
 *
 * @warning
 * - Не проверяет, входит ли фигура в границы буфера 4×4 — предполагается, что
 * TETRIS_NEXT_SIZE >= 4.
 * - Требует, чтобы `next_storage` был выделен и инициализирован.
 *
 * @see tetris_clear_next(), tetris_getPieceData(),
 * tetris_generate_next_piece(), tetris_spawn_piece()
 */
void tetris_update_next_preview(TetrisGame *game);

/* --------------- Коллизии, фиксация и линии -------------------------- */

/**
 * @brief Проверяет, возникает ли коллизия при размещении фигуры на игровом поле
 *
 * Проверяет, может ли указанная фигура быть размещена в своих текущих
 * координатах без выхода за границы поля или пересечения с уже занятыми
 * ячейками. Используется как основной механизм валидации перед перемещением,
 * поворотом или спавном.
 *
 * @param[in] game   Указатель на константный экземпляр игры. Должен быть
 * валидным.
 * @param[in] piece  Указатель на фигуру (TetrisPiece), для которой выполняется
 * проверка. Должна указывать на корректные данные: type в [0,
 * TETRIS_NUM_PIECES-1], rotation в [0, TETRIS_ROTATIONS-1], и допустимые x, y.
 *
 * @return true, если коллизия **обнаружена** (размещение невозможно),
 *         false, если коллизий нет и размещение допустимо.
 *
 * @details
 * Проверка выполняется по каждому ненулевому блоку фигуры:
 * - Выход за левую/правую границу: x + c < 0 или x + c >= TETRIS_FIELD_COLS
 * - Выход за нижнюю границу: y + r >= TETRIS_FIELD_ROWS
 * - Ячейки выше верхней границы (y + r < 0) игнорируются — допустимы при спавне
 * - Если ячейка поля занята (значение > 0) и соответствует ненулевой ячейке
 * фигуры — коллизия
 *
 * Функция использует данные из `tetris_getPieceData(piece->type,
 * piece->rotation)`, чтобы получить форму фигуры, и сравнивает её с текущим
 * состоянием поля (`game->field_storage`).
 *
 * @note
 * - Функция **не изменяет состояние игры** — является чистой (pure) и
 * детерминированной.
 * - Гарантирует потокобезопасность: работает только с const-данными.
 * - Используется в критических участках: движение, поворот, автоматическое
 * падение, спавн.
 *
 * @warning
 * - Поведение не определено, если:
 *   - game == NULL,
 *   - game->field_storage == NULL,
 *   - piece == NULL,
 *   - type или rotation выходят за допустимые пределы (вызов
 * tetris_getPieceData вернёт NULL).
 * - Не выполняет предварительную обработку (например, wall kicks) — только
 * базовая проверка.
 *
 * @see tetris_move_piece(), tetris_rotate_piece(), tetris_spawn_piece(),
 * tetris_getPieceData()
 */
bool tetris_check_collision(const TetrisGame *game, const TetrisPiece *piece);

/**
 * @brief Фиксирует текущую активную фигуру на игровом поле
 *
 * Копирует все ненулевые блоки текущей фигуры (game->current) в игровое поле
 * (game->field_storage) по её фактическим координатам. После фиксации фигура
 * становится частью неподвижного фона, и игра переходит к этапу проверки
 * заполненных линий.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL.
 *                 Если game, game->field_storage или данные фигуры некорректны,
 *                 функция безопасно завершается без изменений.
 *
 * @return true, если фиксация выполнена успешно,
 *         false, если произошла ошибка (например, некорректные данные фигуры
 * или отсутствие поля).
 *
 * @details
 * - Форма фигуры извлекается через tetris_getPieceData(game->current.type,
 * game->current.rotation).
 * - Для каждой ячейки фигуры:
 *   - Если значение > 0,
 *   - и её позиция на поле в пределах допустимых границ,
 *   — значение копируется в соответствующую ячейку игрового поля.
 * - Ячейки, выходящие за нижнюю или боковые границы, игнорируются.
 * - Ячейки выше верхней границы (y < 0) также игнорируются — они не должны быть
 * зафиксированы.
 *
 * @note
 * - Функция не проверяет возможность фиксации — ожидается, что фигура уже была
 * проверена через tetris_check_collision() и находится в допустимой позиции.
 * - После успешной фиксации **обязательно** следует вызвать
 * tetris_clear_full_lines(), чтобы обновить состояние поля и начислить очки.
 * - Изменяет только игровое поле — не влияет на логику FSM, счёт или уровень
 * напрямую.
 *
 * @warning
 * - Не освобождает память и не изменяет состояние фигуры (game->current) —
 *   это делается на последующих этапах.
 * - Не является потокобезопасной: требует эксклюзивный доступ к игровому полю.
 *
 * @see tetris_check_collision(), tetris_clear_full_lines(),
 * tetris_getPieceData(), tetris_apply_cleared_lines()
 */
void tetris_lock_piece(TetrisGame *game);

/**
 * @brief Находит и удаляет полностью заполненные строки на игровом поле
 *
 * Проверяет каждую строку игрового поля на полное заполнение (все ячейки != 0).
 * Удаляет найденные строки, сдвигая всё содержимое выше вниз, и заполняет
 * верхние строки нулями. Используется сразу после фиксации фигуры.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL.
 *                 Если game или game->field_storage не инициализированы,
 * возвращается 0.
 *
 * @return Количество удалённых строк (0–4). В классическом Тетрисе за один раз
 *         может быть удалено от 0 до 4 линий.
 *
 * @details
 * Алгоритм:
 * 1. Сканирование строк сверху вниз (от 0 до TETRIS_FIELD_ROWS-1).
 * 2. Определение, какие строки полностью заполнены (все ячейки != 0).
 * 3. Подсчёт количества полных строк (lines_to_clear).
 * 4. Сдвиг всех строк, находящихся выше полных, вниз на lines_to_clear позиций.
 *    Выполняется за один проход снизу вверх, чтобы избежать перезаписи.
 * 5. Заполнение верхних lines_to_clear строк нулями.
 *
 * Реализация использует эффективный построчный сдвиг через манипуляции
 * указателями или копирование памяти — минимизирует количество операций.
 *
 * @note
 * - Функция изменяет только состояние игрового поля (game->field_storage).
 * - Не обновляет счёт, уровень или количество очищенных линий —
 *   это делается отдельно через tetris_apply_cleared_lines().
 * - Возвращает точное количество строк, чтобы вызывающий код мог рассчитать
 * бонус.
 *
 * @warning
 * - Модифицирует игровое поле напрямую — не является чистой функцией.
 * - Не является потокобезопасной: требует эксклюзивный доступ к
 * game->field_storage.
 * - Не проверяет, была ли вызвана функция lock — ожидается, что фигура уже
 * зафиксирована.
 *
 * @see tetris_lock_piece(), tetris_apply_cleared_lines(),
 * tetris_apply_cleared_lines, tetris_is_line_full()
 */
int tetris_clear_full_lines(TetrisGame *game);

/* ------------------ Спавн и движение фигуры -------------------------- */

/**
 * @brief Генерирует новую случайную фигуру и устанавливает её как следующую
 *
 * Случайным образом выбирает тип и поворот тетромино, устанавливает его
 * начальные координаты в верхней части игрового поля. Сгенерированная фигура
 * сохраняется в поле game->next и будет использоваться при следующем спавне.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае функция не выполняет никаких действий.
 *
 * @details
 * Устанавливает поля структуры `game->next`:
 * - type: случайное значение в диапазоне [0, TETRIS_NUM_PIECES-1],
 * - rotation: случайное значение в диапазоне [0, TETRIS_ROTATIONS-1],
 * - x: центрированная позиция по горизонтали: TETRIS_FIELD_COLS / 2 - 2,
 * - y: начальная позиция по вертикали: 0 (верхняя строка игрового поля).
 *
 * Координата x вычисляется так, чтобы фигура появлялась по центру:
 * - Для поля шириной 10: 10 / 2 - 2 = 3, что соответствует колонкам 3–6 —
 *   стандартное поведение классического Тетриса.
 *
 * @note
 * - Использует rand() для генерации случайных значений. Для равномерного
 * распределения применяется деление по модулю — допустимо при малом количестве
 * значений.
 * - Не обновляет визуальное превью — для отображения необходимо вызвать
 *   tetris_update_next_preview() отдельно.
 * - Рекомендуется вызывать srand() один раз при старте программы, например:
 *   <code>srand(time(NULL));</code> — для настоящей случайности.
 *
 * @warning
 * - Функция не проверяет, была ли предыдущая фигура уже использована —
 *   всегда перезаписывает game->next.
 * - Поведение rand() зависит от инициализации — без вызова srand() генератор
 *   будет выдавать одну и ту же последовательность.
 *
 * @see tetris_spawn_piece(), tetris_update_next_preview(), rand(), srand()
 */
void tetris_generate_next_piece(TetrisGame *game);

/**
 * @brief Спавнит следующую фигуру как текущую активную фигуру
 *
 * Перемещает фигуру из `game->next` в `game->current`, генерирует новую
 * следующую фигуру и обновляет визуальное превью. После размещения проверяет,
 * возможна ли коллизия в начальной позиции. Если фигура не может быть размещена
 * (например, из-за заполнения верхних строк), устанавливает флаг `game_over`,
 * сигнализирующий об окончании игры.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае функция безопасно завершается без изменений.
 *
 * @details
 * Последовательность действий:
 * 1. Копирование `game->next` в `game->current` (с сохранением типа, поворота и
 * координат).
 * 2. Генерация новой следующей фигуры через `tetris_generate_next_piece()`.
 * 3. Обновление буфера превью через `tetris_update_next_preview()`.
 * 4. Проверка коллизии текущей фигуры с игровым полем через
 * `tetris_check_collision()`.
 * 5. Если коллизия обнаружена, устанавливается `game->game_over = true`.
 *
 * Проверка коллизии разрешает наличие части фигуры выше верхней границы (y <
 * 0), но запрещает пересечение с уже занятыми ячейками в пределах поля.
 *
 * @note
 * - Функция используется в ключевых точках: при старте игры и после фиксации
 * фигуры.
 * - Является связующим звеном между логикой фигур и FSM — часто вызывается из
 * состояния SPAWN.
 * - Даже при установке `game_over`, текущая фигура остаётся в `game->current` —
 *   это позволяет отобразить её в интерфейсе до перехода в GAME_OVER.
 *
 * @warning
 * - После вызова **обязательно** проверяйте `game->game_over`, чтобы
 * определить, можно ли продолжать игровой процесс.
 * - Не изменяет состояние FSM напрямую — ожидается, что FSM обработает
 * `game_over` на следующем шаге.
 *
 * @see tetris_generate_next_piece(), tetris_update_next_preview(),
 * tetris_check_collision()
 */
void tetris_spawn_piece(TetrisGame *game);

/**
 * @brief Пытается переместить текущую активную фигуру на заданный вектор
 * смещения
 *
 * Создаёт временную копию текущей фигуры (`game->current`), применяет к ней
 * смещение (dx, dy) и проверяет, допустимо ли новое положение с помощью
 * `tetris_check_collision()`. Если коллизий нет, обновляет позицию текущей
 * фигуры. В противном случае — оставляет её без изменений.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае возвращается false.
 * @param[in] dx   Смещение по горизонтали: -1 (влево), +1 (вправо), 0 (без
 * сдвига).
 * @param[in] dy   Смещение по вертикали: -1 (вверх), +1 (вниз), 0 (без сдвига).
 *
 * @return true, если перемещение успешно выполнено (фигура обновлена),
 *         false, если перемещение невозможно из-за коллизии, выхода за границы
 * или game == NULL.
 *
 * @details
 * Алгоритм:
 * 1. Проверка: если `game` — NULL, возвращается `false`.
 * 2. Создаётся временная копия `next_piece = game->current`.
 * 3. К копии применяется смещение: `next_piece.x += dx`, `next_piece.y += dy`.
 * 4. Проверка допустимости новой позиции через `tetris_check_collision(game,
 * &next_piece)`.
 * 5. Если коллизий нет — `game->current` обновляется; иначе — откат.
 *
 * Функция поддерживает:
 * - Горизонтальные движения (влево/вправо),
 * - Вертикальные (вниз — soft drop, вверх — редко, но возможно),
 * - Диагональные смещения (например, dx=1, dy=1) — при необходимости.
 *
 * @note
 * - Является основным механизмом ввода для перемещения фигуры.
 * - Используется в `tetris_handle_input()` и `tetris_update()` (при тиках
 * падения).
 * - Не изменяет игровое поле — только координаты активной фигуры.
 * - Даже при успешном движении поле перерисовывается только на следующем шаге
 * FSM или визуализации.
 *
 * @warning
 * - Не обновляет `info.field` напрямую — отрисовка зависит от внешнего цикла.
 * - Не генерирует события — логика FSM должна обработать изменение позиции.
 * - Не ограничивает частоту вызова — для предотвращения слишком быстрого
 * движения используйте задержки во вводе или FSM.
 *
 * @see tetris_check_collision(), tetris_handle_input(), tetris_update(),
 * tetris_rotate_piece()
 */
bool tetris_move_piece(TetrisGame *game, int dx, int dy);

/**
 * @brief Пытается повернуть текущую активную фигуру в указанном направлении
 *
 * Создаёт временную копию текущей фигуры, увеличивает или уменьшает её поворот
 * на заданное направление (+1 или -1), корректирует значение по модулю 4
 * (так как доступно 4 ориентации: 0°, 90°, 180°, 270°). Проверяет, может ли
 * фигура быть размещена в новой ориентации без коллизии. Если проверка успешна
 * — применяет новый поворот к текущей фигуре.
 *
 * @param[in] game      Указатель на экземпляр TetrisGame. Может быть NULL — в
 * этом случае возвращается false.
 * @param[in] direction Направление поворота: +1 (по часовой стрелке), -1
 * (против часовой). Другие значения не поддерживаются и приводят к
 * неопределённому поведению.
 *
 * @return true, если поворот выполнен успешно (новая ориентация допустима и
 * применена), false, если:
 *         - game == NULL,
 *         - direction не равен +1 или -1,
 *         - новая ориентация вызывает коллизию,
 *         - не удалось получить данные фигуры для нового поворота.
 *
 * @details
 * Процедура:
 * 1. Проверка: если `game` — NULL, возвращается `false`.
 * 2. Создаётся временная копия `next = game->current`.
 * 3. Обновляется поворот: `next.rotation = (next.rotation + direction + 4) %
 * 4`, где `+4` предотвращает отрицательный остаток при `direction = -1`.
 * 4. Проверяется коллизия новой ориентации через `tetris_check_collision(game,
 * &next)`.
 * 5. Если коллизий нет — `game->current.rotation` обновляется; иначе — поворот
 * отклоняется.
 *
 * Функция **не реализует wall kicks** (сдвиг при коллизии), что характерно для
 * продвинутых систем (например, SRS). В текущей реализации поворот возможен
 * только если новое положение свободно.
 *
 * @note
 * - Является основным интерфейсом вращения фигуры по вводу пользователя.
 * - Используется в `tetris_handle_input()` при нажатии клавиш поворота.
 * - Не изменяет координаты фигуры напрямую — только поворот. Коллизия
 * проверяется в той же позиции.
 * - Даже при успехе отрисовка обновляется только на следующем шаге FSM или
 * визуализации.
 *
 * @warning
 * - Не обновляет `info.field` — отрисовка зависит от внешнего цикла.
 * - Направление должно быть строго +1 или -1. Другие значения (0, 2 и т.д.) не
 * проверяются и могут привести к некорректному поведению.
 * - Не является потокобезопасной — требует эксклюзивного доступа к `game`.
 *
 * @see tetris_check_collision(), tetris_getPieceData(), tetris_handle_input(),
 * tetris_move_piece()
 */
bool tetris_rotate_piece(TetrisGame *game, int direction);

/* ---------------- Счёт, уровень, рекорд ------------------------------ */

/**
 * @brief Применяет результат очистки линий: обновляет счёт, уровень и скорость
 *
 * Начисляет очки в зависимости от количества одновременно удалённых линий
 * (1–4), обновляет общий счёт, рассчитывает текущий уровень и игровую скорость.
 * Автоматически проверяет и обновляет рекорд, если текущий счёт его превысил.
 *
 * @param[in] game  Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае функция не выполняется.
 * @param[in] lines Количество только что очищенных линий. Допустимые значения:
 * 1, 2, 3, 4. Значения вне диапазона игнорируются (функция не выполняет никаких
 * действий).
 *
 * @details
 * Система начисления очков (в зависимости от уровня):
 * - 1 линия: 100  × level
 * - 2 линии: 300  × level
 * - 3 линии: 700  × level
 * - 4 линии: 1500 × level (Tetris!)
 *
 * Уровень (level) вычисляется как:
 *   level = 1 + (total_lines_cleared / 10)
 * где total_lines_cleared — общее количество очищенных линий за игру (включая
 * текущие).
 *
 * После начисления очков вызывается tetris_update_high_score(), чтобы
 * гарантировать, что рекорд отражает актуальное значение.
 *
 * @note
 * - Функция должна вызываться сразу после tetris_clear_full_lines(), если она
 * вернула > 0.
 * - Не изменяет игровое поле — только игровые метрики и состояние.
 * - Уровень и скорость используются FSM и таймером для управления темпом игры.
 *
 * @warning
 * - Поведение не определено, если game != NULL, но game->info.field == NULL.
 * - Значения lines < 1 или > 4 приводят к игнорированию вызова (без начисления
 * очков).
 * - Не является потокобезопасной: требует синхронизации при доступе к игровым
 * счётчикам.
 *
 * @see tetris_clear_full_lines(), tetris_update_high_score(),
 * tetris_spawn_piece(), TetrisGame
 */
void tetris_apply_cleared_lines(TetrisGame *game, int lines);

/**
 * @brief Обновляет рекорд, если текущий счёт превышает сохранённый
 *
 * Сравнивает текущий счёт (game->info.score) с текущим рекордом
 * (game->high_score). Если текущий счёт выше, обновляет внутреннее значение
 * рекорда и публичное поле info.high_score, чтобы UI мог отразить новый рекорд.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае функция безопасно завершается без изменений.
 *
 * @details
 * - Если game == NULL, функция немедленно возвращается.
 * - Функция **всегда** синхронизирует game->info.high_score с актуальным
 * значением рекорда:
 *   - либо с game->high_score (если не превышен),
 *   - либо с game->info.score (если установлен новый рекорд).
 * - Это гарантирует, что пользовательский интерфейс всегда видит корректное
 * значение, даже если рекорд не менялся.
 *
 * @note
 * - Должна вызываться каждый раз при увеличении счёта (например, из
 * tetris_apply_cleared_lines).
 * - Не зависит от FSM — может вызываться в любое время.
 * - Позволяет отображать "живой" рекорд в режиме реального времени (например, в
 * виде анимации при обновлении).
 *
 * @warning
 * - **Не сохраняет рекорд на диск** — для персистентности требуется отдельный
 * вызов tetris_save_high_score().
 * - Работает только с оперативной памятью.
 * - Не является потокобезопасной: одновременный доступ к game->high_score из
 * разных потоков опасен.
 *
 * @see tetris_apply_cleared_lines(), tetris_save_high_score(),
 * tetris_load_high_score()
 */
void tetris_update_high_score(TetrisGame *game);

/**
 * @brief Загружает рекорд из файла сохранения
 *
 * Пытается открыть файл, путь к которому задан в TETRIS_SCORE_FILE, и прочитать
 * из него целочисленное значение — сохранённый рекорд. Если файл не существует,
 * пуст, содержит недопустимые данные или значение отрицательное, рекорд
 * инициализируется как 0. Обновляет как внутреннее поле game->high_score,
 * так и публичное game->info.high_score для отображения в интерфейсе.
 *
 * @param[in] game Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае функция возвращает false.
 *
 * @return true, если файл был успешно открыт и значение (даже 0) было прочитано
 * и принято; false, если:
 *         - game == NULL,
 *         - не удалось открыть файл,
 *         - не удалось прочитать число,
 *         - fscanf вернул значение, отличное от 1,
 *         - значение в файле отрицательное.
 *
 * @details
 * Процедура:
 * 1. Проверка: если game == NULL — возврат false.
 * 2. Открытие файла в режиме "r".
 * 3. Если файл не найден — рекорд устанавливается в 0, возвращается true (файл
 * не обязателен).
 * 4. При успешном открытии: чтение целого числа через fscanf.
 * 5. Проверка: прочитано ровно одно значение (возврат fscanf == 1) и оно >= 0.
 * 6. Если проверка прошла — значение сохраняется в game->high_score.
 * 7. В любом случае (даже при ошибке) game->info.high_score синхронизируется с
 * актуальным значением.
 *
 * @note
 * - Функция **некритична к отсутствию файла** — отсутствие данных не мешает
 * запуску игры.
 * - Должна вызываться при инициализации игры (в tetris_game_create) до других
 * операций с рекордом.
 * - Автоматически сбрасывает повреждённые или отрицательные значения — повышает
 * устойчивость.
 *
 * @warning
 * - Не создаёт директорию .brickgame — предполагается, что она будет создана
 * при первом сохранении.
 * - Не является потокобезопасной: одновременный доступ к файлу из нескольких
 * потоков опасен.
 * - Не блокирует файл — возможны гонки при параллельной записи/чтении.
 *
 * @see tetris_save_high_score(), tetris_update_high_score(), TETRIS_SCORE_FILE,
 * tetris_game_create()
 */
bool tetris_load_high_score(TetrisGame *game);

/**
 * @brief Сохраняет текущий рекорд в файл
 *
 * Сохраняет значение внутреннего рекорда (game->high_score) в файл, путь к
 * которому задан в TETRIS_SCORE_FILE. Перед записью проверяет, существует ли
 * директория .brickgame — если нет, создаёт её с правами 0755. Файл открывается
 * в режиме полной перезаписи ("w").
 *
 * @param[in] game Указатель на константный экземпляр TetrisGame. Может быть
 * NULL — в этом случае функция возвращает false.
 *
 * @return true, если директория успешно создана (или уже существовала) и
 * значение было корректно записано в файл; false, если:
 *         - game == NULL,
 *         - не удалось создать директорию,
 *         - не удалось открыть файл для записи,
 *         - запись не удалась (fprintf вернул <= 0).
 *
 * @details
 * Процедура:
 * 1. Проверка: если game == NULL — возврат false.
 * 2. Попытка создать директорию TETRIS_SCORE_DIR через mkdir() (Unix) или
 * _mkdir() (Windows). Если директория уже существует — ошибка игнорируется.
 * 3. Открытие файла в режиме "w".
 * 4. Запись значения game->high_score и символа новой строки.
 * 5. Проверка результата записи: fprintf должен вернуть положительное число.
 * 6. Закрытие файла.
 *
 * Файл содержит только одну строку с числом, например: "12500\n".
 *
 * @note
 * - Функция **должна вызываться при завершении игры или выходе из приложения**,
 *   чтобы сохранить прогресс между сессиями.
 * - Корректно обрабатывает случай, когда директория уже существует.
 * - Перезаписывает файл полностью — не оставляет предыдущих данных.
 *
 * @warning
 * - **Не является потокобезопасной**: возможны гонки при одновременной записи.
 * - Не блокирует файл — другие процессы могут повредить данные.
 * - На некоторых системах (например, Windows) может потребоваться
 * администраторский доступ для создания директории в домашнем каталоге (редко,
 * но возможно).
 *
 * @see tetris_load_high_score(), tetris_game_destroy(), TETRIS_SCORE_DIR,
 * TETRIS_SCORE_FILE
 */
bool tetris_save_high_score(const TetrisGame *game);

/* -------------------------- FSM Tetris -------------------------------- */

/**
 * @brief Основная функция диспетчеризации событий конечного автомата (FSM) игры
 * Тетрис
 *
 * Обрабатывает входящее событие в контексте текущего состояния игры, управляя
 * переходами между состояниями и вызывая соответствующую логику (движение,
 * поворот, фиксация фигур, пауза и т.д.). Является центральным узлом управления
 * игровым циклом.
 *
 * @param[in] game  Указатель на экземпляр TetrisGame. Может быть NULL — в этом
 * случае функция безопасно завершается без изменений.
 * @param[in] event Событие, которое необходимо обработать (например,
 * TETRIS_EVT_MOVE_LEFT, TETRIS_EVT_TICK, TETRIS_EVT_ROTATE и др.). Должно быть
 * в диапазоне [0, TETRIS_EVT_MAX).
 *
 * @details
 * Логика обработки:
 * - Если game == NULL — функция немедленно завершается.
 * - События сначала обрабатываются особыми правилами в зависимости от
 * состояния:
 *   - В состоянии TETRIS_STATE_FALL:
 *     - TETRIS_EVT_MOVE_LEFT, TETRIS_EVT_MOVE_RIGHT, TETRIS_EVT_ROTATE:
 *       выполняются напрямую через tetris_move_piece() / tetris_rotate_piece(),
 *       состояние не меняется.
 *     - TETRIS_EVT_MOVE_DOWN или TETRIS_EVT_TICK:
 *       пытается сдвинуть фигуру вниз. Если неудача — генерируется внутренний
 * TICK, инициирующий переход в TETRIS_STATE_LOCK.
 *     - TETRIS_EVT_DROP:
 *       выполняет hard drop (многократное движение вниз до отказа), затем
 * генерирует TICK.
 *   - TETRIS_EVT_PAUSE_TOGGLE: переключает паузу (FALL ↔ PAUSED), если игра не
 * окончена.
 *   - TETRIS_EVT_TERMINATE: немедленно переводит игру в GAME_OVER.
 *
 * После предварительной обработки событие передаётся в fsm_process_event(),
 * который выполняет переходы согласно таблице переходов `tetris_transitions`.
 *
 * Наконец, проверяется флаг game->game_over: если он установлен (например,
 * после спавна), и текущее состояние не GAME_OVER, происходит принудительный
 * переход в TETRIS_STATE_GAME_OVER.
 *
 * @note
 * - Функция должна вызываться из:
 *   - tetris_handle_input() — при пользовательском вводе,
 *   - tetris_update() — при каждом игровом тике.
 * - Поддерживает расширяемую архитектуру FSM: логика состояний и переходов
 * отделена.
 * - Автоматически обрабатывает критические условия (game_over) вне зависимости
 * от FSM.
 *
 * @warning
 * - Поведение не определено, если FSM не был инициализирован через fsm_init().
 * - Не проверяет корректность event — ожидается, что он в допустимом диапазоне.
 * - Не является потокобезопасной: одновременный вызов из разных потоков может
 * привести к гонкам.
 *
 * @see TetrisState, TetrisEvent, fsm_process_event(), tetris_handle_input(),
 * tetris_update(), tetris_transitions, tetris_move_piece(),
 * tetris_rotate_piece()
 */
void tetris_fsm_dispatch(TetrisGame *game, TetrisEvent event);

#ifdef __cplusplus
}
#endif

#endif  // S21_TETRIS_INTERNALS_H_

/**
 * @page tetris_fsm_diagram Диаграмма состояний игры Тетрис
 *
 * Ниже представлена корректная диаграмма переходов конечного автомата (FSM)
 * игры Тетрис. Диаграмма точно отражает реализацию в таблице
 * `tetris_transitions[]` и логику обработки событий.
 *
 * @note
 * - Все переходы соответствуют реальным событиям FSM.
 * - Обработка движений и поворотов в состоянии FALL происходит без смены
 * состояния.
 * - События TETRIS_EVT_MOVE_DOWN и TETRIS_EVT_DROP не вызывают прямого перехода
 * в LOCK — они обрабатываются внутри состояния FALL, и только при невозможности
 * движения генерируется TETRIS_EVT_TICK, инициирующий переход.
 * - Переход SPAWN → GAME_OVER происходит автоматически при обнаружении коллизии
 *   после спавна (через TETRIS_EVT_NONE).
 *
 * @dot
 * digraph TetrisFSM {
 *     rankdir=TB;
 *     node [shape=doublecircle]; INIT;
 *     node [shape=circle];
 *
 *     // Основные переходы
 *     INIT      -> SPAWN       [ label = "TETRIS_EVT_START" ];
 *     SPAWN     -> FALL        [ label = "TETRIS_EVT_TICK" ];
 *     SPAWN     -> GAME_OVER   [ label = "TETRIS_EVT_NONE\n(если невозможно
 * разместить)" ];
 *
 *     // Обработка "падения" — движение и поворот без смены состояния
 *     FALL      -> FALL        [ label =
 * "TETRIS_EVT_MOVE_LEFT\nTETRIS_EVT_MOVE_RIGHT\nTETRIS_EVT_ROTATE" ];
 *
 *     // Условие перехода в LOCK: невозможность движения вниз
 *     // Происходит через TETRIS_EVT_TICK после неудачи в
 * tetris_process_fall_input FALL      -> LOCK        [ label =
 * "TETRIS_EVT_TICK\n(при упоре или завершении падения)" ];
 *
 *     // Пауза
 *     FALL      -> PAUSED      [ label = "TETRIS_EVT_PAUSE_TOGGLE" ];
 *     PAUSED    -> FALL        [ label = "TETRIS_EVT_PAUSE_TOGGLE" ];
 *
 *     // Принудительное завершение
 *     FALL      -> GAME_OVER   [ label = "TETRIS_EVT_TERMINATE" ];
 *
 *     // После фиксации — спавн новой фигуры
 *     LOCK      -> SPAWN       [ label = "TETRIS_EVT_TICK" ];
 *
 *     // Перезапуск игры после окончания
 *     GAME_OVER -> INIT        [ label = "TETRIS_EVT_START" ];
 *
 *     // Стилизация
 *     INIT      [color=green, style=filled, fillcolor=lightgreen];
 *     GAME_OVER [color=red,   style=filled, fillcolor=pink];
 *     PAUSED    [color=orange,style=filled, fillcolor=yellow];
 * }
 * @enddot
 *
 * @note Диаграмма построена на основе таблицы tetris_transitions[] и функции
 * tetris_fsm_dispatch(). Обработка soft/hard drop (MOVE_DOWN/DROP) вынесена во
 * внутреннюю логику состояния FALL и не отображается как прямой переход.
 */